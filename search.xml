<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cocoapods私有库制作]]></title>
    <url>%2F2018%2F08%2F19%2FCocoapods-Private_Repo%2F</url>
    <content type="text"><![CDATA[1pod lib create you_lib_name]]></content>
      <categories>
        <category>Cocoapods</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS 自定义控件-UILabel]]></title>
    <url>%2F2018%2F01%2F27%2Fcustom-uicontrol-uilabel%2F</url>
    <content type="text"><![CDATA[开发中经常会遇到 这样的界面,当然你可以使用UIButton来实现. 但是不折腾怎么证明我们存在过 使用自定义UILabel的子类来实现一样的效果,代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public enum EIconEdgeDirection &#123; case left case right&#125;public class IconEdgeInsetsLabel: UILabel &#123; /// UIView 灵活多变 public var iconView: UIView? &#123; didSet&#123; if oldIconView != nil &amp;&amp; oldIconView!.isKind(of: UIView.self) &#123; oldIconView?.removeFromSuperview() &#125; oldIconView = iconView iconView!.x = 0.0 iconView!.y = 0.0 addSubview(iconView!) &#125; &#125; public var edgeInsets: UIEdgeInsets = UIEdgeInsets.zero /// iconView 默认在左边 public var direction: EIconEdgeDirection = .left /// 用于调整iconView 和 文字 之间的间距 public var gap: CGFloat = 0.0 private var oldIconView: UIView? private func sizeToFit(_ text: String) &#123; self.text = text self.sizeToFit() &#125; private func sizeToFit(attributeText: NSAttributedString) &#123; self.attributedText = attributedText self.sizeToFit() &#125; public override func drawText(in rect: CGRect) &#123; var insets = self.edgeInsets if iconView != nil &#123; if self.direction == .left &#123; iconView?.left = insets.left iconView?.centerY = self.middleY insets = UIEdgeInsets(top: insets.top, left: insets.left + gap + iconView!.width, bottom: insets.bottom, right: insets.right) &#125;else if self.direction == .right &#123; iconView?.right = self.width - insets.right iconView?.centerY = self.middleY insets = UIEdgeInsets(top: insets.top, left: insets.left, bottom: insets.bottom, right: insets.right + gap + (iconView?.width)!) &#125; &#125; super .drawText(in: UIEdgeInsetsInsetRect(rect, insets)) &#125; public override func textRect(forBounds bounds: CGRect, limitedToNumberOfLines numberOfLines: Int) -&gt; CGRect &#123; let insets = self.edgeInsets var rect = super.textRect(forBounds: UIEdgeInsetsInsetRect(bounds, insets), limitedToNumberOfLines: numberOfLines) rect.origin.x -= insets.left rect.origin.y -= insets.top rect.size.height += (insets.top + insets.bottom) if iconView != nil &amp;&amp; iconView!.isKind(of: UIView.self) &#123; rect.size.width += (insets.left + insets.right + gap + iconView!.width) &#125;else&#123; rect.size.width += (insets.left + insets.right) &#125; return rect &#125;&#125; .h 12345678910111213141516#import &lt;UIKit/UIKit.h&gt;typedef enum : NSUInteger &#123; kIconAtLeft, kIconAtRight, &#125; EIconEdgeDirection;@interface IconEdgeInsetsLabel : UILabel@property (nonatomic, strong) UIView *iconView;@property (nonatomic) UIEdgeInsets edgeInsets;@property (nonatomic) EIconEdgeDirection direction;@property (nonatomic) CGFloat gap;@end .m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#import "IconEdgeInsetsLabel.h"@interface IconEdgeInsetsLabel ()@property (nonatomic, weak) UIView *oldIconView;@end@implementation IconEdgeInsetsLabel- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines &#123; UIEdgeInsets insets = self.edgeInsets; CGRect rect = [super textRectForBounds:UIEdgeInsetsInsetRect(bounds, insets) limitedToNumberOfLines:numberOfLines]; rect.origin.x -= insets.left; rect.origin.y -= insets.top; rect.size.height += (insets.top + insets.bottom); _iconView &amp;&amp; [_iconView isKindOfClass:[UIView class]] ? (rect.size.width += (insets.left + insets.right + _gap + _iconView.frame.size.width)) : (rect.size.width += (insets.left + insets.right)); return rect;&#125;- (void)drawTextInRect:(CGRect)rect &#123; UIEdgeInsets insets = self.edgeInsets; if (self.iconView) &#123; if (self.direction == kIconAtLeft) &#123; _iconView.left = insets.left; _iconView.centerY = self.middleY; insets = UIEdgeInsetsMake(insets.top, insets.left + _gap + _iconView.frame.size.width, insets.bottom, insets.right); &#125; else if (self.direction == kIconAtRight) &#123; _iconView.right = self.width - insets.right; _iconView.centerY = self.middleY; insets = UIEdgeInsetsMake(insets.top, insets.left, insets.bottom, insets.right + _gap + _iconView.frame.size.width); &#125; &#125; [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];&#125;- (void)sizeToFitWithText:(NSString *)text &#123; self.text = text; [self sizeToFit];&#125;- (void)sizeToFitWithAttrText:(NSAttributedString *)text &#123; self.attributedText = text; [self sizeToFit];&#125;#pragma mark - setter &amp; getter.@synthesize iconView = _iconView;- (void)setIconView:(UIView *)iconView &#123; _oldIconView &amp;&amp; [_oldIconView isKindOfClass:[UIView class]] ? ([_oldIconView removeFromSuperview]) : 0; _iconView = iconView; _oldIconView = iconView; iconView.x = 0.f; iconView.y = 0.f; [self addSubview:iconView];&#125;- (UIView *)iconView &#123; return _iconView;&#125;@end 那么实际中如何使用呢?swift12345678910111213lazy var vipTypeLabel: IconEdgeInsetsLabel = &#123; let l: IconEdgeInsetsLabel = IconEdgeInsetsLabel() l.textColor = UIColor(hex: 0xFF8A00) l.backgroundColor = .white l.layer.cornerRadius = 2 l.layer.masksToBounds = true l.text = "零售价" l.edgeInsets = UIEdgeInsets(top: 1, left: 2, bottom: 1, right: 2) l.textAlignment = .center l.iconView = UIImageView(image: UIImage.init(named: "img_name")) l.direction = .right return l&#125;() oc12345678910111213- (IconEdgeInsetsLabel *)iconLabel &#123; if(_iconLabel) return _iconLabel; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 12, 12)]; imageView.image = [UIImage imageNamed:@"right_arrow_orange"]; _iconLabel = [IconEdgeInsetsLabel new]; _iconLabel.direction = kIconAtRight; _iconLabel.gap = 4; _iconLabel.iconView = imageView; _iconLabel.textColor = HEXCOLOR(0xFF8A00); _iconLabel.font = SystemFontWithPxSize(14.f); _iconLabel.textAlignment = NSTextAlignmentCenter; return _iconLabel;&#125; 参考textrectforbounds limitedtonumberoflines]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UILabel</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios集成cordova自定义插件以及在vue中的使用.]]></title>
    <url>%2F2018%2F01%2F04%2Fhow-to-use-cordova-custom-plugin-in-vue%2F</url>
    <content type="text"><![CDATA[开始前, 先吐槽一波, 这段话后面的”,”后面的空格看见了么, 这是ES6的语法, 折磨我半天.开始前,先吐槽一波,这段话后面的”,”后面的空格看见了么,这是ES6的语法,折磨我半天.没有对比就没有伤害, 心在滴血😂N 年不用的js,差一点 就 LFAT, 我的元旦三天假…😂 ——————————— 华丽丽的开始了,准备好你们的道具 ————————————##1.项目创建基于 webpack 模板创建一个 vue 项目 cordova : cordova create hello com.example.hello HelloWord 第一个参数 hello 表示在工程目录中创建一个 hello 的文件夹 第二个参数 com.example.hello 表示包名（反向域名），用于标志不同的 app 第三个参数 HelloWord表示项目的名称，可以在 config.xml 文件中修改 创建基于 webpack 模板的 vue 项目 vue : vue init webpack my-project ##2.添加cordova项目的平台支持 2.1 进入创建的项目目录cd hello 2.2 查看已有的平台cordova platforms list 2.3添加所需要的平台cordova platform add androidcordova platform add ios 2.4如果想移除已经添加的平台的话cordova platform remove android or cordova platform rm android ##3.pluman 的安装 3.1安装 plugmannpm install -g plugman 3.2创建 plugman 插件 语法如下:plugman create --name &lt;pluginName&gt; --plugin_id &lt;pluginID&gt; --plugin_version &lt;version&gt; [--path &lt;directory&gt;] [--variableNAME=VALUE] egg : plugman create --name hello --plugin_id firstPlugin --plugin_version 0.0.1 123456参数:pluginName: 插件名字pluginID: 插件id, egg : coolPlugin oversion: 版本, egg : 0.0.1directory:一个绝对或相对路径的目录，该目录将创建插件项目variable NAME=VALUE: 额外的描述，如作者信息和相关描述 回到 cordova 创建项目目录下 找到 platforms 下 的 ios / android 项目在 plugin 目录下 编写需要的 native文件 (native 文件也可以后面写) 将编写好的 native 插件 放入 cordova 插件下的 src 目录 规范化的处理是 建立平台文件夹 放入 对应的平台文件夹中 这里 以 iOS 为例 检查 plugin.xml 配置文件相关节点的配置123456789101112131415161718&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;plugin id="firstPlugin" version="0.0.1" xmlns="http://apache.org/cordova/ns/plugins/1.0" xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;name&gt;hello&lt;/name&gt; &lt;js-module name="hello" src="www/hello.js"&gt; &lt;!-- &lt;clobbers target="cordova.plugins.hello" /&gt; --&gt; &lt;clobbers target="navigator.hello" /&gt; &lt;/js-module&gt; &lt;platform name="ios"&gt; &lt;config-file target="config.xml" parent="/*"&gt; &lt;feature name="HelloWord"&gt; &lt;param name="ios-package" value="CDVHelloWord"/&gt; &lt;param name="onload" value="true" /&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;header-file src="src/ios/CDVHelloWord.h" /&gt; &lt;source-file src="src/ios/CDVHelloWord.m" /&gt; &lt;/platform&gt;&lt;/plugin&gt; 这样创建的插件 是不能安装的 缺少 package.json 文件 执行 plugman createpackagejson 插件目录 生成 package.json 插件信息文件(terminal会让你输入一些东西) 如下: 前两行是创建插件的时候 自带的信息 没有发布到 git 所以可以没填 name: (firstPlugin) version: (0.0.1) description: 测试插件 git repository: author: 348043793@qq.com license: (ISC) MIT 插件添加正常 提示如下 : name: (coolPlugin) version: (0.0.1) description: 测试插件 git repository: author: 348043793@qq.com license: (ISC) MIT About to write to /Users/ooops/Desktop/oc_vue/package.json: { &quot;name&quot;: &quot;coolPlugin&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;测试插件&quot;, &quot;cordova&quot;: { &quot;id&quot;: &quot;coolPlugin&quot;, &quot;platforms&quot;: [ &quot;ios&quot; ] }, &quot;keywords&quot;: [ &quot;ecosystem:cordova&quot;, &quot;cordova-ios&quot; ], &quot;author&quot;: &quot;348043793@qq.com&quot;, &quot;license&quot;: &quot;MIT&quot; } Is this ok? (yes) 编写插件代码这个根据业务 / 逻辑 需要自行编写 (请自行使用 百度 google 一下), 放出一个简单的示例1234567891011121314151617181920var exec = require('cordova/exec'); // 固定格式var options = &#123;quality: '200'&#125;; // 没什么卵用的参数// exports.sayHi 扩展一个插件的方法/** &lt;feature name="HelloWord"&gt; &lt;param name="ios-package" value="CDVHelloWord"/&gt; &lt;param name="onload" value="true" /&gt; &lt;/feature&gt;* * exec(success, error, 'HelloWord', 'sayHello', [options]);* success 成功回调,* error 失败回调,* HelloWord 上面 feature 中的 name,* sayHello CDVHelloWord(原生文件)中的函数名 / 方法名, 需要传递给原生的参数(字典 / 字典数组) * exec(success, error, 'HelloWord', 'sayHello', [options]);*/ exports.sayHi = function (options, success, error) &#123; exec(success, error, 'HelloWord', 'sayHello', [options]);&#125;; 安装编写的插件cd 插件目录 执行 pwd 得到当前插件目录 /Users/ooops/Desktop/plugins/hello cd cordova 项目目录 执行 cordova plugin add 插件目录 输出信息 如下 表示插件安装成功 : Installing &quot;SimpleMath&quot; for android Android Studio project detected Installing &quot;SimpleMath&quot; for ios Adding SimpleMath to package.json Saved plugin info for &quot;SimpleMath&quot; to config.xml vue-cordova 插件的使用在线安装 - 这个不做介绍了 坑了我两天本地安装 为什么要本地安装？ 现有的插件不够，如果要调用自己开发的插件，在线的不能用，只能将项目放在Vue项目中根据实际情况自 己添加插件 如果已安装了 vue-cordova ,控制台执行 npm uninstall vue-cordova 删除掉 在 github 上 clone 下 vue-cordova 项目 git clone https://github.com/kartsims/vue-cordova.git 在 Vue 项目的 src 目录下新建一个 cordova 目录 将下载的 vue-cordova src目录下的 index.js copy 到 Vue 项目新建的 cordova 目录下面，命名为 cordova-plugin-index.js ,不要使用 index.js ，否则会出现命名冲突 main.js 的导包改成下面的样子： 12import VueCordova from './cordova/cordova-plugin-index.js'Vue.use(VueCordova) App.vue 中 需要1import Vue from 'vue' 到这里 环境基本搞好了 如何安装本地插件在 Vue 项目文件的 cordova 目录下新建一个 plugins 目录 在 src/cordova/plugins/ 目录下新建 cordova-plugin-sayhi.js ,按照 camera 插件仿造的一个 js 文件 1234567891011exports.install = function (Vue, options, cb) &#123; document.addEventListener('deviceready', () =&gt; &#123; if (typeof navigator.hello === 'undefined') &#123; return cb(false) &#125; // 关键点 Vue.cordova.hello = navigator.hello return cb(true) &#125;, false)&#125; 其中 navigator.hello 为 插件的 config.xml 中的 &lt;clobbers target=&quot;navigator.hello&quot; /&gt; 节点中的内容 将自定义的插件 添加到 cordova-plugin-index.js 中 如下位置 123const pluginsList = [ 'cordova-plugin-sayhi'] Vue 中调用插件 1&lt;button v-on:click="click"&gt;Add 1&lt;/button&gt; 123456789101112131415import Vue from 'vue' // 这个很重要, 否则会报 Vue is undefinedexport default &#123; name: 'app', methods: &#123; click: function () &#123; window.alert(Vue); Vue.cordova.hello.saiHi(&#123;quality: '200'&#125;, function (success) &#123; window.alert(success); &#125;, function (error) &#123; window.alert(error) &#125;) &#125; &#125;&#125; 存在的问题 上述解决方案 适用于 vue 整个项目打包 扔进 app 使用 webpack 打包 app 如果 H5 集成的过多 app 安装包势必会越来越大……. 请看下面的描述 1234567891011121314151617181920212223猜想找不到插件, 插件是存在的,只是他找不到,调用插件是需要依赖库的,em 貌似很有道理插件需要依赖的文件,先导入看看.# 验证猜想 尝试1 window.alert(Vue.cordova.plugins);在 index.html文件中手动加入 cordova.js打印 插件数组 ...............ok - ☺如何让他 找到这个插件....继续摸索糊里糊涂的 又引用了 exec.js 文件解决: 打包整个项目放到服务器找不到插件 在index.html中 添加如下两个文件的引用&lt;script type=text/javascript src=cordova.js&gt;&lt;/script&gt;&lt;script type=text/javascript src=cordova-js-src/exec.js&gt;&lt;/script&gt;// 这两句没什么卵用 - 有没有一样?&lt;script type=text/javascript src=cordova-js-src/platform.js&gt;&lt;/script&gt;&lt;script type=text/javascript src=cordova_plugins.js&gt;&lt;/script&gt; 至此 Vue 和 native 可以交互 - 至于姿势 自由选择 可以解锁—————————————- 就这么华丽丽的结束了 —————————————-参考链接 Vue Document vue-cordova Document]]></content>
      <categories>
        <category>cordova</category>
      </categories>
      <tags>
        <tag>cordova</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS AttributeString]]></title>
    <url>%2F2017%2F12%2F18%2Fattributestring%2F</url>
    <content type="text"><![CDATA[Getting StartedOPAttributeString is available through CocoaPods. To installit, simply add the following line to your Podfile: 1pod 'OPAttributeString' How To UseObjective-C123456NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.font([UIFont fontWithName:@"Courier New" size:12]); make.textColor([UIColor redColor]); make.backgroundColor([UIColor greenColor]);&#125;]; or you can write like this.123456NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.font([UIFont fontWithName:@"Courier New" size:12]) .textColor([UIColor redColor]) .backgroundColor([UIColor greenColor]);&#125;]; or this minimalist writing123456NSString *despicableMe = @"I know someone whoabccan fix that for you.";self.someLabel.attributedText = despicableMe.font([UIFont fontWithName:@"Courier New" size:12]).textColor([UIColor redColor]).backgroundColor([UIColor greenColor]).string; now you can see it. But most of the time , you want set a part attribute of string. there is some API can use.from(index)If the index parameter exceeds the string range, the correction processing rules are as follows: (index &lt; 0 || index &gt; string.length) ? 0 : index; 1234NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.from(0).font([UIFont systemFontOfSize:10]);&#125;]; to(index)the correction processing rules are as follows: (index &lt; 0 || index &gt; string.length) ? string.length : index; 12345NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.font([UIFont systemFontOfSize:10]); make.to(5).font([UIFont systemFontOfSize:17]);&#125;]; fromTo(location,length)the correction processing rules are as follows location rules: same with from(index). length rules: same with to(index). 123456NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.font([UIFont systemFontOfSize:10]); make.to(5).font([UIFont systemFontOfSize:17]); make.fromTo(8,12).backgroundColor([UIColor orangeColor]);&#125;]; range(NSRange)use it like fromTo(location,length)123456NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.font([UIFont systemFontOfSize:10]); make.to(5).font([UIFont systemFontOfSize:17]); make.range(NSMakeRange(0,10)).backgroundColor([UIColor orangeColor]);&#125;]; the correction processing rules are as follows1234NS_INLINE BOOL rangeCheck(NSRange range, NSRange rangeContainer) &#123; if(range.location &lt; 0 || rangeContainer.location &lt; 0 || rangeContainer.location &gt; range.length) return false; return range.location &lt;= rangeContainer.location &amp;&amp; range.length &gt;= rangeContainer.length;&#125; rangeOf(somestring)Use this function to find the range of characters or strings.1234NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.rangeOf(@"fix").strokeColor([UIColor blueColor]).strokeWidth(3);&#125;]; insert(…)this is a multi-parameter function, roughly as follows: first case: insert a string to source string123456789NSString *despicableMe = @"I know someone whoabccan fix that for you.";self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; // default insert a string to the end of source string make.insert(@"\n"); // or you can specified a string and index to insert // the index parameter has rules same way to(index) used // so -1 means 'ooops' will be inserted to the end make.insert(@"ooops",-1);&#125;]; second case: insert a NSAttributedString to source string123456789NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@"e"];[string addAttribute:NSBackgroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 1)];NSString *despicableMe = @"I know someone whoabccan fix that for you.";self.someLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.insert(string); make.insert(string,-1);&#125;]; let us change the diffrent index paramters.12make.insert(string,0);make.insert(string,-1); then will display like this third case: insert a UIImage to source string123456NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.demoLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; UIImage *img = [UIImage imageNamed:@"old_sj"]; make.insert(img, 0, CGRectMake(0, 0, 18, 18), AttachmentAlignmentNormal);&#125;]; append(…)you can use it like insert(…), the difference between inserting and appending, appending always adding characters or strings to the end of the source string.12345678NSMutableAttributedString *attributeString = @"e".backgroundColor([UIColor redColor]).string;UIImage *img = [UIImage imageNamed:@"old_sj"];self.demoLabel.attributedText = @"".append(@"_append").append(attributeString).append(@"\r\n").append(img,CGRectMake(0, 0, 18, 18),AttachmentAlignmentNormal).string; regex pattern12345NSString *despicableMe = @"I know someone whoabccan fix that for you."; self.demoLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; make.pattern(@"o").strokeColor([UIColor redColor]).strokeWidth(-5);&#125;]; remove some char or string from source string, you can do it like by this way.1234567891011NSString *despicableMe = @&quot;I know someone whoabccan fix that for you.&quot;; self.demoLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; // remove all char &apos;o&apos; from source string. // defalut matching hole source string. make.removeE(@[@&quot;o&quot;]); // specified range make.removeE(@[@&quot;o&quot;],, NSMakeRange(0, 10)); // mult-matching and specified range. make.removeE(@[@&quot;e&quot;,@&quot;o&quot;], NSMakeRange(0, 10));&#125;]; replace some char or string from source string, you can do it like by this way.range rule: rangeCheck c function123456789101112131415NSString *despicableMe = @&quot;I know someone whoabccan fix that for you.&quot;; self.demoLabel.attributedText = [despicableMe make_Attribute:^(OPAttribute *make) &#123; // matching the hole source string make.replace(@&quot;o&quot;,@&quot;O&quot;); // matching the hole source string in range make.replace(@&quot;o&quot;,@&quot;O&quot;,NSMakeRange(0, 8)); // mult-matching the hole string with dictionary // dictionary&apos;s key will matching. // the dictionary key&apos;s matching value will be replaced by dictionary&apos;s value. // defalut matching hole source string. make.replaceE(@[@&#123;@&quot;e&quot; : @&quot;o&quot;&#125;,@&#123;@&quot;y&quot; : @&quot;Y&quot;&#125;]); // in the same way ... in range make.replaceE(@[@&#123;@&quot;o&quot; : @&quot;0&quot;&#125;,@&#123;@&quot;n&quot; : @&quot;u&quot;&#125;],NSMakeRange(0, 8));&#125;]; Authorurm9ril, 348043793@qq.com]]></content>
      <tags>
        <tag>AttributeString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 全屏截图分享组件]]></title>
    <url>%2F2017%2F08%2F31%2Ffullscreen-capture%2F</url>
    <content type="text"><![CDATA[项目需求用户在任意界面截屏可分享至微信和QQ平台,且需在分享的图片拼接上一些必要的信息,如 说明,App Store下载链接二维码等. 思路获取截屏通知,获取当前屏幕的图片上下文,再绘制所需的信息到上下文,最后得到想要的图片 应为是应用内全局都需要使用,所以编写Appdelegate分类的方式实现. .h12345678910111213141516171819#import "AppDelegate.h"@interface AppDelegate (Capture)/** 注册 快捷键 截屏通知 */- (void)registerCaptureScreenNotification;/** 获取带二维码信息的当前屏幕有截图 @param needCode 是否需要二维码 @return 返回屏幕截图 */- (UIImage *)imageWithScreenshotNeedCode:(BOOL)needCode;@end .m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#import "AppDelegate+Capture.h"#import "CaptureTipView.h"#import "ShareView.h"@interface AppDelegate ()/** 截屏图片 */@property (nonatomic, strong) UIImage *screenImage;@end@implementation AppDelegate (Capture)- (void)registerCaptureScreenNotification &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(userDidTakeScreenshot:) name:UIApplicationUserDidTakeScreenshotNotification object:nil]; // 点击分享按钮的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(captureShare) name:CaptureTipViewShareButtonTouchedNotification object:nil];&#125;//截屏响应- (void)userDidTakeScreenshot:(NSNotification *)notification &#123; //人为截屏, 模拟用户截屏行为, 获取所截图片 self.screenImage = [self imageWithScreenshotNeedCode:YES]; if(self.screenImage) &#123; [CaptureTipView show]; &#125; &#125;- (void)captureShare &#123; ShareView *share = [[ShareView alloc] initWithShareHeadOprationWith:@"" shareDesc:@"" shareLogo:self.screenImage urlString:nil]; [share show];&#125;- (UIImage *)imageWithScreenshotNeedCode:(BOOL)needCode &#123; NSData *imageData = [self dataWithScreenshotInPNGFormatNeedCode:needCode]; return [UIImage imageWithData:imageData];&#125;/** * 截取当前屏幕 * * @return NSData * */- (NSData *)dataWithScreenshotInPNGFormatNeedCode:(BOOL)needCode&#123; CGSize imageSize = CGSizeZero; UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation; if (UIInterfaceOrientationIsPortrait(orientation)) imageSize = [UIScreen mainScreen].bounds.size; else imageSize = CGSizeMake([UIScreen mainScreen].bounds.size.height, [UIScreen mainScreen].bounds.size.width); if(needCode) &#123; // 价格条件 - 是否需要 添加 二维码等信息 // 背景图 UIImage *bgImage = [UIImage imageNamed:@"capture_share_bottom_bg"]; CGFloat bgH = AutoHieght(319); imageSize = CGSizeMake(imageSize.width, imageSize.height + bgH); // logo 图 UIImage *logoImage = [UIImage imageNamed:@"capture_share_logo"]; // 二维码 图 UIImage *codeImage = [UIImage imageNamed:@"capture_share_code"]; UIGraphicsBeginImageContextWithOptions(imageSize, NO, 0); // 绘制背景图片到上下文 CGRect bgRect = CGRectMake(0, kScreenHeight, kScreenWidth, bgH); [bgImage drawInRect:bgRect]; // 绘制logo 图片到上下文 CGFloat logoH = AutoHieght(92), logoW = AutoWidth(79), logoY = AutoHieght(20) + kScreenHeight; CGRect logoRect = CGRectMake(kScreenWidth * .5 - logoW * .5, logoY, logoW, logoH); [logoImage drawInRect:logoRect]; // 绘制二维码到上下文 CGFloat codeH = AutoHieght(110), codeW = codeH, codeY = logoY + logoH + AutoHieght(25); CGRect codeRect = CGRectMake(kScreenWidth * .5 - codeW * .5, codeY, codeW, codeH); [codeImage drawInRect:codeRect]; //绘制到指定的区域内容 NSString *str = @"设置你的APP的个性标语....."; CGRect rect= CGRectMake(0, codeY + codeH + AutoHieght(26), kScreenWidth, 40); UIFont *font = HelveticaNeueFontWithPxSize(15); //设置字体 UIColor *color = HEXCOLOR(0x333333); //字体颜色 NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init]; //段落样式 NSTextAlignment align = NSTextAlignmentCenter; //对齐方式 style.alignment = align; [str drawInRect:rect withAttributes:@&#123;NSFontAttributeName:font, NSForegroundColorAttributeName:color, NSParagraphStyleAttributeName:style&#125;]; &#125;else &#123; UIGraphicsBeginImageContextWithOptions(imageSize, NO, 0); &#125; CGContextRef context = UIGraphicsGetCurrentContext(); for (UIWindow *window in [[UIApplication sharedApplication] windows]) &#123; CGContextSaveGState(context); CGContextTranslateCTM(context, window.center.x, window.center.y); CGContextConcatCTM(context, window.transform); CGContextTranslateCTM(context, -window.bounds.size.width * window.layer.anchorPoint.x, -window.bounds.size.height * window.layer.anchorPoint.y); if (orientation == UIInterfaceOrientationLandscapeLeft) &#123; CGContextRotateCTM(context, M_PI_2); CGContextTranslateCTM(context, 0, -imageSize.width); &#125; else if (orientation == UIInterfaceOrientationLandscapeRight) &#123; CGContextRotateCTM(context, -M_PI_2); CGContextTranslateCTM(context, -imageSize.height, 0); &#125; else if (orientation == UIInterfaceOrientationPortraitUpsideDown) &#123; CGContextRotateCTM(context, M_PI); CGContextTranslateCTM(context, -imageSize.width, -imageSize.height); &#125; if ([window respondsToSelector:@selector(drawViewHierarchyInRect:afterScreenUpdates:)]) &#123; [window drawViewHierarchyInRect:window.bounds afterScreenUpdates:YES]; &#125; else &#123; [window.layer renderInContext:context]; &#125; CGContextRestoreGState(context); &#125; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return UIImagePNGRepresentation(image);&#125;- (void)setScreenImage:(UIImage *)screenImage &#123; objc_setAssociatedObject(self, @selector(screenImage), screenImage, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (UIImage *)screenImage &#123; return objc_getAssociatedObject(self, _cmd);&#125;@end tips: 使用runtime 为分类添加属性的应用 ShareView 为自定义分享界面,可自己根据实际需求编写 CaptureTipView 为顶部是否分享提示界面 CaptureTipView.h123456789#import &lt;UIKit/UIKit.h&gt;extern NSString * const CaptureTipViewShareButtonTouchedNotification;@interface CaptureTipView : UIView+ (void)show;@end CaptureTipView.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#import "CaptureTipView.h"static UIWindow *window_;static NSTimer *timer_;/** 动画持续时间（出现\隐藏） */static CGFloat const AnimationDuration = 0.25;/** 控件默认会停留多长时间 */static CGFloat const ControlStayDuration = 3;static CGFloat WindowH = 89, WindowMargin = 8;NSString * const CaptureTipViewShareButtonTouchedNotification = @"CaptureTipViewShareButtonTouchedNotification";@interface CaptureTipView ()/** 标题 */@property (nonatomic, strong) UILabel *tipLabel;/** 按钮 */@property (nonatomic, strong) UIButton *shareButton;@end@implementation CaptureTipView+ (void)show &#123; // 停止之前的定时器 [timer_ invalidate]; // 创建窗口 window_.hidden = YES; // 先隐藏之前的window window_ = [[UIWindow alloc] init]; window_.backgroundColor = HEXCOLORA(0xFFFFFF, .96); window_.layer.cornerRadius = 8; window_.layer.shadowColor = HEXCOLOR(0x000000).CGColor; window_.layer.shadowRadius = 8; window_.layer.shadowOffset = CGSizeMake(3.0f, 5.0f); window_.layer.shadowOpacity = .3; window_.windowLevel = UIWindowLevelAlert; window_.frame = CGRectMake(AutoWidth(WindowMargin), - AutoWidth(WindowH), kScreenWidth - AutoWidth(WindowMargin) * 2, AutoWidth(WindowH)); window_.hidden = NO; // 滑动消失 UISwipeGestureRecognizer * swipe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(hide)]; swipe.direction = UISwipeGestureRecognizerDirectionUp; [window_ addGestureRecognizer:swipe]; UILabel *tipLabel = [UILabel new]; tipLabel.text = @"分享截图给好友"; tipLabel.font = HelveticaNeueFontWithPxSize(15); tipLabel.textColor = HEXCOLOR(0x666666); tipLabel.textAlignment = NSTextAlignmentCenter; tipLabel.clipsToBounds = YES; //tipLabel.backgroundColor = [UIColor redColor]; tipLabel.frame = CGRectMake(0, AutoHieght(14), window_.width, 16); [window_ addSubview:tipLabel]; UIButton *shareButton = [UIButton buttonWithType:0]; [shareButton setTitle:@"分享" forState:UIControlStateNormal]; [shareButton setTitleColor:HEXCOLOR(0xFFFFFF) forState:UIControlStateNormal]; [shareButton.layer setCornerRadius:8]; [shareButton setBackgroundColor:kYellowColor]; [shareButton setFrame:CGRectMake(0, 0, AutoWidth(80), AutoHieght(30))]; [shareButton setCenter:CGPointMake(window_.width * .5, tipLabel.bottom + AutoHieght(14) + AutoHieght(14))]; [shareButton touchUpInside:^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:CaptureTipViewShareButtonTouchedNotification object:nil]; [self hide]; &#125;]; [window_ addSubview:shareButton]; // 动画 [UIView animateWithDuration:AnimationDuration animations:^&#123; CGRect frame = window_.frame; frame.origin.y = WindowMargin + (iPhoneX ? 24 : 0); window_.frame = frame; &#125;]; // 开启一个新的定时器 timer_ = [NSTimer scheduledTimerWithTimeInterval:ControlStayDuration target:self selector:@selector(hide) userInfo:nil repeats:NO];&#125;+ (void)hide &#123; // 清空定时器 [timer_ invalidate]; timer_ = nil; // 退出动画 [UIView animateWithDuration:AnimationDuration animations:^&#123; CGRect frame = window_.frame; frame.origin.y = - AutoWidth(WindowH); window_.frame = frame; &#125; completion:^(BOOL finished) &#123; window_ = nil; [[NSNotificationCenter defaultCenter] removeObserver:self name:CaptureTipViewShareButtonTouchedNotification object:nil]; &#125;];&#125;@end 在Appdelegate1234- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; /// 注册全屏截图通知 [self registerCaptureScreenNotification];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>截图分享</tag>
        <tag>分享组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XLForm 表单库的复杂使用 - 地址选择器]]></title>
    <url>%2F2017%2F06%2F25%2FXLForm-Complex-AreaPicker%2F</url>
    <content type="text"><![CDATA[这次来点特别的 组头的使用.根据上一篇博文XLForm 表单库使用说明的介绍,简单改造一下,先创建只有两个组头的表单. ComplexConst 常量文件 123// 组头信息NSString *const kCompanyInfo = @"公司信息";NSString *const kContactInfo = @"联系人"; ComplexFactory 表单创建工厂类文件 123456789- (void)initForm &#123; XLFormSectionDescriptor * companySection = [XLFormSectionDescriptor formSectionWithTitle:kCompanyInfo]; [self.form addFormSection:companySection]; XLFormSectionDescriptor * contactSection = [XLFormSectionDescriptor formSectionWithTitle:kContactInfo]; [self.form addFormSection:contactSection];&#125; 效果如下: 自定义组头我们需要利用一下代理方法123- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section// 控制组头高度- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section 我们先来自定义一个组头视图 SectionHeaderView .h 12345@interface SectionHeaderView : UIView- (instancetype)initWithIndicatorColor:(UIColor *)indicatorColor sectionTitle:(NSString *)sectionTitle;@end .m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@interface SectionHeaderView()/** indicatorView - 指示器 */@property (nonatomic, strong) UIView *indicatorView;/** titleV - 标题视图 */@property (nonatomic, strong) UILabel *titleLabel;@end@implementation SectionHeaderView &#123; UIColor *_indicatorColor; NSString *_sectionTitle;&#125;- (instancetype)initWithIndicatorColor:(UIColor *)indicatorColor sectionTitle:(NSString *)sectionTitle &#123; _indicatorColor = indicatorColor; _sectionTitle = sectionTitle; if(self = [super initWithFrame:CGRectZero]) &#123; [self setupUI]; [self makeConstraint]; self.indicatorView.backgroundColor = _indicatorColor; self.titleLabel.text = sectionTitle; &#125; return self;&#125;- (void)setupUI &#123; [self addSubview:self.indicatorView]; [self addSubview:self.titleLabel];&#125;- (void)makeConstraint &#123; [self.indicatorView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self).offset(20); make.centerY.equalTo(self); make.height.mas_equalTo(17); make.width.mas_equalTo(3); &#125;]; [self.titleLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.indicatorView.mas_right).offset(6); make.centerY.equalTo(self.indicatorView); make.right.equalTo(self); &#125;];&#125;- (UIView *)indicatorView &#123; if(_indicatorView) return _indicatorView; _indicatorView = [UIView new]; return _indicatorView;&#125;- (UILabel *)titleLabel &#123; if(_titleLabel) return _titleLabel; _titleLabel = [UILabel new]; _titleLabel.textColor = [UIColor orangeColor]; _titleLabel.font = [UIFont systemFontOfSize:16]; return _titleLabel;&#125;@end viewController.m 中 123456789101112131415161718192021@interface ViewController ()/** 表头视图显示标题数组 */@property (nonatomic, strong) NSArray *sectionHeadViewTitleArray;- (void)viewDidLoad &#123; [super viewDidLoad]; self.sectionHeadViewTitleArray = @[kCompanyInfo, kContactInfo];&#125;......@end- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123; NSString *sectionTitle = [NSString stringWithFormat:@"%@",self.sectionHeadViewTitleArray[section]]; SectionHeaderView *sectionHeadView = [[SectionHeaderView alloc] initWithIndicatorColor:HEXCOLOR(0xFF8A00) sectionTitle:sectionTitle]; return sectionHeadView;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; return 30.f;&#125; 好了 跑一下看看吧. 自定义地址选择器我们现在在第一组里面增加一个自定义的 地址选择器 cell 回顾一下自定义 cell 的套路. 1.load 注册自定义的 cell. 2.configure 初始化一些 cell 配置信息. 3.update 更新 XLFromRowDescriptor 对象的 value 属性值. ComplexAreaCell.h1234567891011#import "XLFormBaseCell.h"extern NSString * const XLFormRowDescriporTypeComplexArea;@interface ComplexAreaCell : XLFormBaseCell@property (nonatomic, readonly) UILabel *textLabel;@property (nonatomic, readonly) UITextField *textField;@property (nonatomic, readonly) UIImageView *accessorry;@end ComplexAreaCell.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#import "ComplexAreaCell.h"#import &lt;XLForm/XLForm.h&gt;NSString * const XLFormRowDescriporTypeComplexArea = @"XLFormRowDescriporTypeComplexArea";@interface ComplexAreaCell()&lt;UIPickerViewDelegate, UIPickerViewDataSource&gt;/** pickView */@property (nonatomic, strong) UIPickerView *pickerView;@end@implementation ComplexAreaCell@synthesize textLabel = _textLabel;@synthesize textField = _textField;@synthesize accessorry = _accessorry;// 在主表单中加入一组Key Value 自定义的必须重写+ (void)load &#123; [XLFormViewController.cellClassesForRowDescriptorTypes setObject:[self class] forKey:XLFormRowDescriporTypeComplexArea];&#125;- (UIView *)inputView &#123; if ([self.rowDescriptor.rowType isEqualToString:XLFormRowDescriporTypeComplexArea])&#123; return self.pickerView; &#125; return [super inputView];&#125;- (BOOL)formDescriptorCellCanBecomeFirstResponder &#123; return (!self.rowDescriptor.isDisabled &amp;&amp; ([self.rowDescriptor.rowType isEqualToString:XLFormRowDescriporTypeComplexArea]));&#125;- (BOOL)formDescriptorCellBecomeFirstResponder &#123; return [self becomeFirstResponder];&#125;- (BOOL)canBecomeFirstResponder &#123; if ([self.rowDescriptor.rowType isEqualToString:XLFormRowDescriporTypeComplexArea])&#123; return YES; &#125; return [super canBecomeFirstResponder];&#125;#pragma mark - Properties- (UIPickerView *)pickerView &#123; if (_pickerView) return _pickerView; _pickerView = [[UIPickerView alloc] init]; _pickerView.delegate = self; _pickerView.dataSource = self; _pickerView.backgroundColor = HEXCOLOR(0xFFFFFF); return _pickerView;&#125;#pragma mark - XLFormDescriptorCell 配置cell- (void)configure &#123; [super configure]; self.currentProvinceId = self.currentCityId = self.currentAreaId = -1; [self setSelectionStyle:UITableViewCellSelectionStyleNone]; [self setupUI]; [self makeConstraint];&#125;- (void)setupUI &#123; [self.contentView addSubview:self.textLabel]; [self.contentView addSubview:self.textField]; [self.contentView addSubview:self.accessorry];&#125;- (void)makeConstraint &#123; [self.textLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.contentView).offset(5); make.left.equalTo(self.contentView).offset(20); make.right.equalTo(self.contentView).offset(-20); &#125;]; [self.textField mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.textLabel.mas_bottom).offset(10); make.left.equalTo(self.textLabel); make.right.equalTo(self.textLabel); make.height.mas_equalTo(44); make.bottom.equalTo(self.contentView).offset(-5); &#125;]; [self.accessorry mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.equalTo(self.textField); make.right.equalTo(self.textField.mas_right).offset(-5); &#125;];&#125;- (void)update &#123; [super update]; if ([self.rowDescriptor.rowType isEqualToString:XLFormRowDescriporTypeComplexArea])&#123; self.textField.autocorrectionType = UITextAutocorrectionTypeDefault; self.textField.autocapitalizationType = UITextAutocapitalizationTypeSentences; &#125; self.textField.text = self.areaString ? self.areaString : @"请选择"; [self.textField setEnabled:!self.rowDescriptor.isDisabled]; self.textField.leftView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 12, self.textField.frame.size.height)]; self.textField.textColor = HEXCOLOR(0x000000); self.textField.leftViewMode = UITextFieldViewModeAlways; self.textField.layer.borderColor = HEXCOLOR(0xCCCCCC).CGColor; self.textField.layer.borderWidth = 1; self.textField.font = [UIFont systemFontOfSize:15]; self.textField.textAlignment = NSTextAlignmentCenter; self.textField.enabled = NO;&#125;- (NSInteger)numberOfComponentsInPickerView:(UIPickerView*)pickerView &#123; return 3;&#125;- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component &#123; return 3;&#125;- (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component &#123; return @"test";&#125;- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component &#123; self.textField.text = @"test_a";&#125;- (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component &#123; return 44;&#125;- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(nullable UIView *)view &#123; //设置分割线的颜色 for(UIView *singleLine in pickerView.subviews) &#123; if (singleLine.frame.size.height &lt; 1) &#123; singleLine.backgroundColor = HEXCOLOR(0xCCCCCC); &#125; &#125; //设置文字的属性 UILabel *genderLabel = [UILabel new]; genderLabel.textAlignment = NSTextAlignmentCenter; genderLabel.text = [self pickerView:pickerView titleForRow:row forComponent:component]; genderLabel.font = [UIFont systemFontOfSize:20]; return genderLabel;&#125;#pragma mark - Helpers- (NSInteger)selectedIndex &#123; if (self.rowDescriptor.value)&#123; for (id option in self.rowDescriptor.selectorOptions)&#123; if ([[option valueData] isEqual:[self.rowDescriptor.value valueData]])&#123; return [self.rowDescriptor.selectorOptions indexOfObject:option]; &#125; &#125; &#125; return -1;&#125;-(UILabel *)textLabel &#123; if (_textLabel) return _textLabel; _textLabel = [UILabel autolayoutView]; _textLabel.textAlignment = NSTextAlignmentRight; return _textLabel;&#125;- (UITextField *)textField &#123; if(_textField) return _textField; _textField = [UITextField autolayoutView]; return _textField;&#125;- (UIImageView *)accessorry &#123; if(_accessorry) return _accessorry; _accessorry = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"pullDown"]]; return _accessorry;&#125;#pragma mark - cell的点击触发事件-(void)formDescriptorCellDidSelectedWithFormController:(XLFormViewController *)controller &#123; self.textField.text = [NSString stringWithFormat:@"%@-%@-%@",provinceName,cityName,areaName];&#125;@end ComplexFactory.m 改造123456789101112131415- (void)initForm &#123; XLFormSectionDescriptor * companySection = [XLFormSectionDescriptor formSectionWithTitle:kCompanyInfo]; [companySection addFormRow:[self rowFactoryWithWithTitle:@"* 地区" tag:kArea required:YES rowType:XLFormRowDescriporTypeComplexArea placeholder:@"请选择"]]; [self.form addFormSection:companySection]; XLFormSectionDescriptor * contactSection = [XLFormSectionDescriptor formSectionWithTitle:kContactInfo]; [self.form addFormSection:contactSection];&#125; 好了 ,再来看一下效果 地址数据用到了第三方 YYModel 模型编写IVModel.h123456789101112131415161718192021222324252627282930#import &lt;Foundation/Foundation.h&gt;@interface IAreaModel : NSObject/** id */@property (nonatomic, strong) NSNumber *ID;/** name */@property (nonatomic, strong) NSString *name;/** level */@property (nonatomic, strong) NSString *level;/** parent_id */@property (nonatomic, strong) NSString *parent_id;@end@interface ICityModel : NSObject/** id */@property (nonatomic, strong) NSNumber *ID;/** name */@property (nonatomic, strong) NSString *name;/** level */@property (nonatomic, strong) NSString *level;/** parent_id */@property (nonatomic, strong) NSString *parent_id;/** aereList */@property (nonatomic, strong) NSArray&lt;IAreaModel *&gt; *areaList;@end IVModel.m1234567891011121314151617181920212223242526272829303132333435363738394041424344#import "IVModel.h"@implementation IVModel : NSObject// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"citylist" : [IModel class]&#125;;&#125;@end@implementation IModel : NSObject+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@"ID" : @"id"&#125;;&#125;// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"areaList" : [ICityModel class]&#125;;&#125;@end@implementation IAreaModel+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@"ID" : @"id"&#125;;&#125;@end@implementation ICityModel+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@"ID" : @"id"&#125;;&#125;// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"areaList" : [IAreaModel class]&#125;;&#125;@end 数据文件及解析方法viewController 中添加获取数据的方法.12345- (void)loadData &#123; NSString *str = [[NSBundle mainBundle] pathForResource:@"json" ofType:@"txt"]; NSDictionary *result = [NSJSONSerialization JSONObjectWithData:[NSData dataWithContentsOfFile:str] options:0 error:NULL]; self.factory.provinceModel = [IVModel yy_modelWithDictionary:result];&#125; 自定义cell的改造ComplexAreaCell.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358#import "ComplexAreaCell.h"#import &lt;XLForm/XLForm.h&gt;#import "IVModel.h"NSString * const XLFormRowDescriporTypeComplexArea = @"XLFormRowDescriporTypeComplexArea";@interface ComplexAreaCell()&lt;UIPickerViewDelegate, UIPickerViewDataSource&gt;/** pickView */@property (nonatomic, strong) UIPickerView *pickerView;/** ids */@property (nonatomic, copy) NSString *areaString;//数据模型@property (nonatomic, strong) IVModel *provinceModel;/** province模型数组 */@property (nonatomic, strong) NSArray&lt;IModel *&gt; *provinceModelArray;/** city模型数组 */@property (nonatomic, strong) NSArray&lt;ICityModel *&gt; *cityModelArray;/** area模型数组 */@property (nonatomic, strong) NSArray&lt;IAreaModel *&gt; *areaModelArray;/** province ID */@property (nonatomic,assign) NSInteger currentProvinceId;/** city ID */@property (nonatomic,assign) NSInteger currentCityId;/** area ID */@property (nonatomic,assign) NSInteger currentAreaId;@end@implementation ComplexAreaCell@synthesize textLabel = _textLabel;@synthesize textField = _textField;@synthesize accessorry = _accessorry;// 在主表单中加入一组Key Value 自定义的必须重写+ (void)load &#123; [XLFormViewController.cellClassesForRowDescriptorTypes setObject:[self class] forKey:XLFormRowDescriporTypeComplexArea];&#125;- (UIView *)inputView &#123; if ([self.rowDescriptor.rowType isEqualToString:XLFormRowDescriporTypeComplexArea])&#123; return self.pickerView; &#125; return [super inputView];&#125;- (BOOL)formDescriptorCellCanBecomeFirstResponder &#123; return (!self.rowDescriptor.isDisabled &amp;&amp; ([self.rowDescriptor.rowType isEqualToString:XLFormRowDescriporTypeComplexArea]));&#125;- (BOOL)formDescriptorCellBecomeFirstResponder &#123; return [self becomeFirstResponder];&#125;- (BOOL)canBecomeFirstResponder &#123; if ([self.rowDescriptor.rowType isEqualToString:XLFormRowDescriporTypeComplexArea])&#123; return YES; &#125; return [super canBecomeFirstResponder];&#125;#pragma mark - Properties- (UIPickerView *)pickerView &#123; if (_pickerView) return _pickerView; _pickerView = [[UIPickerView alloc] init]; _pickerView.delegate = self; _pickerView.dataSource = self; _pickerView.backgroundColor = HEXCOLOR(0xFFFFFF); return _pickerView;&#125;#pragma mark - XLFormDescriptorCell 配置cell- (void)configure &#123; [super configure]; self.currentProvinceId = self.currentCityId = self.currentAreaId = -1; [self setSelectionStyle:UITableViewCellSelectionStyleNone]; [self setupUI]; [self makeConstraint];&#125;- (void)setupUI &#123; [self.contentView addSubview:self.textLabel]; [self.contentView addSubview:self.textField]; [self.contentView addSubview:self.accessorry];&#125;- (void)makeConstraint &#123; [self.textLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.contentView).offset(5); make.left.equalTo(self.contentView).offset(20); make.right.equalTo(self.contentView).offset(-20); &#125;]; [self.textField mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.textLabel.mas_bottom).offset(10); make.left.equalTo(self.textLabel); make.right.equalTo(self.textLabel); make.height.mas_equalTo(44); make.bottom.equalTo(self.contentView).offset(-5); &#125;]; [self.accessorry mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.equalTo(self.textField); make.right.equalTo(self.textField.mas_right).offset(-5); &#125;];&#125;- (void)titleHighLight &#123; NSString *title = self.rowDescriptor.title; self.textLabel.font = [UIFont fontWithName:@"HelveticaNeue" size:12]; NSMutableAttributedString *str = [[NSMutableAttributedString alloc] initWithString:[NSString stringWithFormat:@"%@",title]]; NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; // 首行缩进 paragraphStyle.alignment = NSTextAlignmentLeft; if([title rangeOfString:@"*"].location != NSNotFound) &#123; [str addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,1)]; &#125; [str addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [title length])]; [str addAttribute:NSFontAttributeName value:[UIFont fontWithName:@"HelveticaNeue" size:12] range:NSMakeRange(0, [title length])]; self.textLabel.attributedText = str; &#125;- (void)update &#123; [super update]; if ([self.rowDescriptor.rowType isEqualToString:XLFormRowDescriporTypeComplexArea])&#123; self.textField.autocorrectionType = UITextAutocorrectionTypeDefault; self.textField.autocapitalizationType = UITextAutocapitalizationTypeSentences; &#125; [self titleHighLight]; self.textField.text = self.areaString ? self.areaString : @"请选择"; [self.textField setEnabled:!self.rowDescriptor.isDisabled]; self.textField.leftView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 12, self.textField.frame.size.height)]; self.textField.textColor = HEXCOLOR(0x000000); self.textField.leftViewMode = UITextFieldViewModeAlways; self.textField.layer.borderColor = HEXCOLOR(0xCCCCCC).CGColor; self.textField.layer.borderWidth = 1; self.textField.font = [UIFont systemFontOfSize:15]; self.textField.textAlignment = NSTextAlignmentCenter; self.textField.enabled = NO; [self preSelectedValue];&#125;/** 设置每次应该默认选中的项 */- (void)preSelectedValue &#123; if(!self.rowDescriptor.value) return; NSString __block *provinceName,__block *cityName,__block *areaName ; NSString *ids = nil; if([self.rowDescriptor.value isKindOfClass:[XLFormOptionsObject class]]) &#123; ids = [self.rowDescriptor.value formValue]; &#125;else&#123; ids = self.rowDescriptor.value; &#125; if(!ids) return; NSArray *idss = [ids componentsSeparatedByString:@"-"]; if(!idss) return; if(!self.provinceModelArray) return; [self.provinceModelArray enumerateObjectsUsingBlock:^(IModel * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if([obj.ID integerValue] == [idss[0] integerValue]) &#123; self.currentProvinceId = idx; provinceName = obj.name; *stop = YES; &#125; [obj.areaList enumerateObjectsUsingBlock:^(ICityModel * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if([obj.ID integerValue] == [idss[1] integerValue]) &#123; self.currentCityId = idx; cityName = obj.name; *stop = YES; &#125; [obj.areaList enumerateObjectsUsingBlock:^(IAreaModel * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if([obj.ID integerValue] == [idss[2] integerValue]) &#123; self.currentAreaId = idx; areaName = obj.name; *stop = YES; &#125; &#125;]; &#125;]; &#125;]; self.textField.text = [NSString stringWithFormat:@"%@-%@-%@",provinceName,cityName,areaName];&#125;- (NSInteger)numberOfComponentsInPickerView:(UIPickerView*)pickerView &#123; return 3;&#125;- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component &#123; if (0 == component) &#123; return self.provinceModelArray.count; &#125; else if (1 == component) &#123; NSInteger rowProvince = [pickerView selectedRowInComponent:0]; self.cityModelArray = self.provinceModelArray[rowProvince].areaList; if(self.currentProvinceId &gt;= 0) &#123; self.cityModelArray = self.provinceModelArray[self.currentProvinceId].areaList; &#125; return self.cityModelArray.count &gt; 0 ? self.cityModelArray.count : 1; &#125; else &#123; NSInteger rowProvince1 = [pickerView selectedRowInComponent:1]; self.areaModelArray = self.cityModelArray[rowProvince1].areaList; if(self.currentCityId &gt;= 0) &#123; self.areaModelArray = self.cityModelArray[self.currentCityId].areaList; &#125; return self.areaModelArray.count &gt; 0 ? self.areaModelArray.count : 1; &#125;&#125;- (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component &#123; if (0 == component) &#123; return self.provinceModelArray[row].name; &#125; else if(1 == component)&#123; if(self.cityModelArray.count == 1) return self.cityModelArray[0].name; return self.cityModelArray[row].name; &#125;else&#123; if(self.areaModelArray.count == 1) return self.areaModelArray[0].name; return self.areaModelArray[row].name; &#125;&#125;- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component &#123; self.currentProvinceId = [self.pickerView selectedRowInComponent:0]; self.currentCityId = [self.pickerView selectedRowInComponent:1]; self.currentAreaId = [self.pickerView selectedRowInComponent:2]; switch (component) &#123; case 0: self.currentCityId = 0; self.cityModelArray = nil; self.cityModelArray = self.provinceModelArray[self.currentProvinceId].areaList; [self.pickerView reloadComponent:1]; [self.pickerView reloadComponent:2]; //让刷新后的第一和二 个滚轮重新回到第一行 [self.pickerView selectRow:0 inComponent:1 animated:YES]; [self.pickerView selectRow:0 inComponent:2 animated:YES]; break; case 1: self.currentAreaId = 0; self.areaModelArray = nil; self.areaModelArray = self.cityModelArray[self.currentCityId].areaList; [self.pickerView reloadComponent:2]; //让刷新后的第二个滚轮重新回到第一行 [self.pickerView selectRow:0 inComponent:2 animated:YES]; break; default: break; &#125; // 获取城市ID NSString *procinveID = [self.provinceModelArray[[self.pickerView selectedRowInComponent:0]].ID stringValue]; NSString *cityID = [self.cityModelArray[[self.pickerView selectedRowInComponent:1]].ID stringValue]; NSString *areaID = [self.areaModelArray[[self.pickerView selectedRowInComponent:2]].ID stringValue]; // 记录当前选中行 self.currentProvinceId = [self.pickerView selectedRowInComponent:0]; self.currentCityId = [self.pickerView selectedRowInComponent:1]; self.currentAreaId = [self.pickerView selectedRowInComponent:2]; // 获取城市名字 NSString *provinceName = self.provinceModelArray[[self.pickerView selectedRowInComponent:0]].name; NSString *cityName = self.cityModelArray[[self.pickerView selectedRowInComponent:1]].name; NSString *areaName = self.areaModelArray[[self.pickerView selectedRowInComponent:2]].name; self.rowDescriptor.value = [NSString stringWithFormat:@"%@-%@-%@",procinveID,cityID,areaID]; self.textField.text = [NSString stringWithFormat:@"%@-%@-%@",provinceName,cityName,areaName]; self.areaString = [NSString stringWithFormat:@"%@-%@-%@",provinceName,cityName,areaName];&#125;- (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component &#123; return 44;&#125;- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(nullable UIView *)view &#123; //设置分割线的颜色 for(UIView *singleLine in pickerView.subviews) &#123; if (singleLine.frame.size.height &lt; 1) &#123; singleLine.backgroundColor = HEXCOLOR(0xCCCCCC); &#125; &#125; //设置文字的属性 UILabel *genderLabel = [UILabel new]; genderLabel.textAlignment = NSTextAlignmentCenter; genderLabel.text = [self pickerView:pickerView titleForRow:row forComponent:component]; genderLabel.font = [UIFont systemFontOfSize:20]; return genderLabel;&#125;#pragma mark - Helpers- (NSInteger)selectedIndex &#123; if (self.rowDescriptor.value)&#123; for (id option in self.rowDescriptor.selectorOptions)&#123; if ([[option valueData] isEqual:[self.rowDescriptor.value valueData]])&#123; return [self.rowDescriptor.selectorOptions indexOfObject:option]; &#125; &#125; &#125; return -1;&#125;-(UILabel *)textLabel &#123; if (_textLabel) return _textLabel; _textLabel = [UILabel autolayoutView]; _textLabel.textAlignment = NSTextAlignmentRight; return _textLabel;&#125;- (UITextField *)textField &#123; if(_textField) return _textField; _textField = [UITextField autolayoutView]; return _textField;&#125;- (UIImageView *)accessorry &#123; if(_accessorry) return _accessorry; _accessorry = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"pullDown"]]; return _accessorry;&#125;#pragma mark - 数据设置- (void)setProvinceModel:(IVModel *)provinceModel &#123; _provinceModel = provinceModel; self.provinceModelArray = _provinceModel.citylist; [self.pickerView reloadAllComponents];&#125;#pragma mark - cell的点击触发事件-(void)formDescriptorCellDidSelectedWithFormController:(XLFormViewController *)controller &#123; NSString *provinceName, *cityName, *areaName ; if(self.currentProvinceId &gt;= 0) &#123; [self.pickerView selectRow:self.currentProvinceId inComponent:0 animated:NO]; provinceName = self.provinceModelArray[self.currentProvinceId].name; self.cityModelArray = self.provinceModelArray[self.currentProvinceId].areaList; &#125; if(self.currentCityId &gt;= 0) &#123; [self.pickerView selectRow:self.currentCityId inComponent:1 animated:NO]; cityName = self.cityModelArray[self.currentCityId].name; self.areaModelArray = self.cityModelArray[self.currentCityId].areaList; &#125; if(self.currentAreaId &gt;= 0) &#123; [self.pickerView selectRow:self.currentAreaId inComponent:2 animated:NO]; areaName = self.areaModelArray[self.currentAreaId].name; &#125; if(!provinceName &amp;&amp; !cityName &amp;&amp; !areaName) &#123; return; &#125; // 为了第一次点击cell的时候设置value NSString *procinveID = [self.provinceModelArray[[self.pickerView selectedRowInComponent:0]].ID stringValue]; NSString *cityID = [self.cityModelArray[[self.pickerView selectedRowInComponent:1]].ID stringValue]; NSString *areaID = [self.areaModelArray[[self.pickerView selectedRowInComponent:2]].ID stringValue]; self.rowDescriptor.value = [NSString stringWithFormat:@"%@-%@-%@",procinveID,cityID,areaID]; self.textField.text = [NSString stringWithFormat:@"%@-%@-%@",provinceName,cityName,areaName]; self.areaString = [NSString stringWithFormat:@"%@-%@-%@",provinceName,cityName,areaName];&#125;@end 表单创建类 ComplexFactoryComplexFactory.h 中增加记录地址数据的属性12/** IVModel 城市联动数据模型 */@property (nonatomic, strong) IVModel *provinceModel; ComplexFactory.m 中通过 kvc 赋值 provinceModel 地址数据.12345678910111213141516- (XLFormRowDescriptor *)rowFactoryWithWithTitle:(NSString *)headerTitle tag:(NSString *)tag required:(BOOL)required rowType:(NSString *)rowType placeholder:(NSString *)placeholder &#123; XLFormRowDescriptor *row; row = [XLFormRowDescriptor formRowDescriptorWithTag:tag rowType:rowType]; if(tag == kArea) &#123; [row.cellConfig setValue:self.provinceModel forKey:@"provinceModel"]; &#125; if(required) &#123; row.requireMsg = @"带*为必填!"; &#125; row.required = required; row.title = headerTitle; row.height = UITableViewAutomaticDimension; return row;&#125; 数据验证器ComplexRegValidator.m 的验证方法.123+ (XLFormValidator *)areaValidator &#123; return [XLFormRegexValidator formRegexValidatorWithMsg:NSLocalizedString(@"请选择地址", nil) regex:@"^((?!请选择).)*$"];&#125; ComplexFactory.m123......[row addValidator:[ComplexRegValidator areaValidator]];...... ComplexValidator.m123456......if ([validationStatus.rowDescriptor.tag isEqualToString:kArea] &amp;&amp; !validationStatus.isValid) &#123; *stop = YES; // show hud .... &#125;...... 好了,结束了.来看一下 gif 补上最想要的 Demo]]></content>
      <categories>
        <category>XLForm</category>
      </categories>
      <tags>
        <tag>XLForm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo图床之七牛云]]></title>
    <url>%2F2017%2F06%2F13%2Fqiniuyun%2F</url>
    <content type="text"><![CDATA[为什么使用七牛云写 MarkDown 使用 Sublime Text ,可配合使用 数据同步插件,方便. 优点: 相对于直接部署 hexo d 到 github 来说访问速度更快. 空间大 稳定 七牛云空间设置1.注册七牛云账户 2.创建七牛云存储空间 3.点击页面右上角头像→进入”密钥管理“→复制当前使用中的AK和SK，待会设置插件时会用到. 设置 hexo-qiniu-sync 插件1.安装插件:在hexo主目录下运行以下命令: npm install hexo-qiniu-sync --save hexo-qiniu-sync github 2.添加插件配置到站点配置文件 _config.yml plugins: hexo-qiniu-sync qiniu: offline: false sync: true bucket: image access_key: ak secret_key: sk dirPrefix: urlPrefix: http://paj20wmcz.bkt.clouddn.com local_dir: cdn update_exist: true image: folder: images js: folder: js css: folder: css 几个需要修改的地方: bucket: 修改为你刚才申请的七牛空间名称access_key secret_key:上传密钥AccessKey、SecretKey.即3 第3步复制的AK和SK.urlPrefix: 七牛空间地址的前缀.重要！必填！ http://paj20wmcz.bkt.clouddn.com 你可以进入自己创建的空间在域名设置中看到自己的七牛测试域名,这个参数的设置是保证解析成网页文件时，外链地址正确的关键之一！ 参数说明 offline :是否离线.设置为 true 将在本地预览时使用本地地址渲染，省流量 false 将使用同步到七牛空间的静态资源渲染，方便检查资源链接是否正确. sync :是否同步到七牛，一般都是设置 true . dirPrefix :资源将上传到七牛空间的此目录下，可像我一样设置为空.该参数会影响外链的地址，如果设置为非空值，例如默认值 static ，则 urlPrefix 为保持一致需加上目录后缀 /static ，改为 http://paj20wmcz.bkt.clouddn.com/static . local_dir :本地资源储存目录.在本例中，待上传的资源都储存在 hexo 主目录中的 cdn 文件夹（也就是与 source 目录平级）中. update_exist :设置为 true ，则会在文件更新之后重新上传并更新七牛空间上中的原有文件. image/js/css :子参数 folder 为不同静态资源种类的目录名称，一般不需要改动 配置本地目录本地目录名称需要与 local_dir 参数的值一致。所以在 hexo 主目录 下新建与 source 平级的目录 cdn ，用于存放需要上传到七牛的资源。 在 cdn 目录下创建子目录： css 、 images 、 js ，与 image/js/css 子参数 folder 保持一致，待上传的 css、image、js 文件应该存储到相应子目录。也可新建其他子目录,用于不同文件类型的存放 Hexo主目录结构如下： ├─.deploy_git ├─cdn │ ├─css │ ├─images │ └─js ├─node_modules ├─public ├─scaffolds ├─source └─theme MarkDown 中如何使用七牛资源?这里正好使用到了之前安装的插件 插入图片资源1&#123;% qnimg xxx.png %&#125; 高级一点的用法1&#123;% qnimg xxxx.png title:标题 alt:说明 'class:class1 class2' %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 一个版本多渠道分享 - 使用OpenInstall]]></title>
    <url>%2F2017%2F06%2F11%2Fmulti-channe%2F</url>
    <content type="text"><![CDATA[产品需求一个 ipa 包适应多个渠道分享. 调研方案最终选择 OpenInstall 最终使用中发现,并不能满足需求,只有安装完渠道包App后的第一次启动才会走 OpenInstall 的回调方法,所以 扑街 . 猜想: 是否可以从 OpenInstall 本身入手.OpenInstall 是否有记录是否第一次启动的相关文件? 实施: 模拟器方案放弃,无法扫描二维码.😓 1.连接真机调试,查看沙盒文件 Window-&gt;Devices 2.导出 App 沙盒内容 3.查看沙盒数据 4.查看用户偏好设置AppData –&gt; Library –&gt; Preferences –&gt; yourBundleId.plist 最终找到如下 key openinstall_firstLaunch 于是尝试设置为 NO 12345678910111213141516171819202122232425262728293031323334353637383940414243//通过OpenInstall 获取自定义参数，数据为空时也会回调此方法。渠道统计返回参数名称为 openinstallChannelCode- (void)getInstallParamsFromOpenInstall:(NSDictionary *) params withError: (NSError *) error &#123; if (!error) &#123; if (params) &#123; if ([params.allKeys containsObject:@"channels"]) &#123; [GlobalModel defaultModel].channelName = params[@"channels"]; &#125;else&#123; [GlobalModel defaultModel].channelName = String(params.allValues.firstObject); &#125; NSString *paramsStr = [NSString stringWithFormat:@"channelName = %@",[GlobalModel defaultModel].channelName]; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"我是" message:paramsStr preferredStyle: UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; /// 弹出提示框(便于调试，调试完成后删除此代码) [self.window.rootViewController presentViewController:alert animated:true completion:nil]; &#125; /** * 事实上 , 当回 openinstall 调完成后 , 偏好设置已经存储了 channelName, 即可重置 openinstall 的启动状态. * 这样 做的原因是 , 每次app 启动都可以接收到 openinstall sdk 向 openinstall 服务器 请求 channelName 数据(如果有这个数据的话) * 当然 没有数据的时候 是不走这个 方法的 * 这样做的目的是为了 适应 一个版本下 N 个渠道... */ NSUserDefaults *openinstallData = [NSUserDefaults standardUserDefaults]; [openinstallData setBool:NO forKey:@"openinstall_firstLaunch"]; [openinstallData synchronize]; &#125; else &#123; NSString *paramsStr = [NSString stringWithFormat:@"channelName = %@",[GlobalModel defaultModel].channelName ?: @"没取到"]; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"我是" message:paramsStr preferredStyle: UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; /// 弹出提示框(便于调试，调试完成后删除此代码) [self.window.rootViewController presentViewController:alert animated:true completion:nil]; &#125; [[UserAnalysisManager manager] sendAppFirstLauchDataToServer];&#125; 至此需求完成.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OpenInstall</tag>
        <tag>Objective-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-域名解析(阿里云)]]></title>
    <url>%2F2017%2F05%2F25%2Fhexo-domain-alicloud%2F</url>
    <content type="text"><![CDATA[自从Hexo博客搭建完成,每次访问都要输入urm9ril.github.io一长串域名来访问,这就很尴尬了😓. 购买一个短一点的域名,通过解析DNS,达到通过域名访问博客的目的 购买域名网上找了一下,最终选择了阿里万网的.top域名,因为成本低,一年只需要4RMB,性价比相当之高. 域名认证登录进入阿里云控制台,点击域名和网站中的 ‘域名’,刚购买的域名需要进行实名认证. 填写认证资料,等待审核,一般一个工作日内就能通过审核了,如果你填写的资料没有问题的话. 域名解析 点击解析 需要添加两条A记录一天CNAME记录 192.30.252.153 , 192.30.252.154 地址来自 GitHub Pages Hexo 配置在 hexo 下的 source 下新建名为 CNAME 无文件后缀的文件, 文件内容为购买的域名 urm9ril.top hexo c hexo g hexo d 重新部署 blog 到 github 现在喝口水吧, 稍等一会即可通过购买的urm9til.top来访问你的 blog 了]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>域名解析</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XLForm 表单库使用说明]]></title>
    <url>%2F2017%2F05%2F02%2FXLForm-usage%2F</url>
    <content type="text"><![CDATA[简述XLForm 应该算是 iOS 平台上最灵活且最强大的动态表单库了, 以下是简单的结构图 最主要的上图红色框里的三个类文件XLFormRowDescriptor，XLFormSectionDescriptor，XLFormDescriptor 1.XLFormDescriptor结构和 UITablView 一样，有 Section ,有 Row,它就是为成为 UITableView 的数据源而设计的. 2.XLFormRowDescriptor 定义了每行表单的数据内容,包括行样式,标题,行类型,选择项内容,标签,合法性验证等. 3.XLFormSectionDescriptor 是由 XLFormRowDescriptor 组合而成的,而 XLFormSectionDescriptor 最终又组成了 XLFormDescriptor. 简单用法1. 创建一个继承自 XLFormViewController 的 ViewController 2. 编写创建表单的代码 1234567891011121314151617- (void)initForm &#123; // 创建 `XLFormDescriptor` 对象,等同于创建了 `UITableView` XLFormDescriptor *form = [XLFormDescriptor formDescriptorWithTitle:@"First Form"]; // 创建 `XLFormSectionDescriptor` 组对象 XLFormSectionDescriptor *section = [XLFormSectionDescriptor formSectionWithTitle:@"First Section"]; // 创建 `XLFormRowDescriptor` 对象,相当于 `UITableViewCell` // `XLFormRowDescriptorTypePhone` 是 `XLForm` 框架自带的 `XLFormRowDescriptorType` 类型 // 具体参见文件 `XLForm.h` 头文件 XLFormRowDescriptor *row = [XLFormRowDescriptor formRowDescriptorWithTag:@"PhoneRow" rowType:XLFormRowDescriptorTypePhone]; // 组内添加 `XLFormRowDescriptor` 对象 [section addFormRow:row]; // 表单添加 `XLFormSectionDescriptor` 组对象 [form addFormSection:section]; // 赋值创建的表单, `self.form` 是当前控制器持有的 `XLFormDescriptor` 对象 self.form = form;&#125; 调用 12345- (void)viewDidLoad &#123; [super viewDidLoad]; [self initForm];&#125; Command + R 效果如下 具体的 XLFormRowDescriptorType1234567891011121314151617181920212223242526272829303132333435363738394041NSString *const XLFormRowDescriptorTypeText = @"text";NSString *const XLFormRowDescriptorTypeName = @"name";NSString *const XLFormRowDescriptorTypeURL = @"url";NSString *const XLFormRowDescriptorTypeEmail = @"email";NSString *const XLFormRowDescriptorTypePassword = @"password";NSString *const XLFormRowDescriptorTypeNumber = @"number";NSString *const XLFormRowDescriptorTypePhone = @"phone";NSString *const XLFormRowDescriptorTypeTwitter = @"twitter";NSString *const XLFormRowDescriptorTypeAccount = @"account";NSString *const XLFormRowDescriptorTypeInteger = @"integer";NSString *const XLFormRowDescriptorTypeImage = @"image";NSString *const XLFormRowDescriptorTypeDecimal = @"decimal";NSString *const XLFormRowDescriptorTypeTextView = @"textView";NSString *const XLFormRowDescriptorTypeZipCode = @"zipCode";NSString *const XLFormRowDescriptorTypeSelectorPush = @"selectorPush";NSString *const XLFormRowDescriptorTypeSelectorPopover = @"selectorPopover";NSString *const XLFormRowDescriptorTypeSelectorActionSheet = @"selectorActionSheet";NSString *const XLFormRowDescriptorTypeSelectorAlertView = @"selectorAlertView";NSString *const XLFormRowDescriptorTypeSelectorPickerView = @"selectorPickerView";NSString *const XLFormRowDescriptorTypeSelectorPickerViewInline = @"selectorPickerViewInline";NSString *const XLFormRowDescriptorTypeMultipleSelector = @"multipleSelector";NSString *const XLFormRowDescriptorTypeMultipleSelectorPopover = @"multipleSelectorPopover";NSString *const XLFormRowDescriptorTypeSelectorLeftRight = @"selectorLeftRight";NSString *const XLFormRowDescriptorTypeSelectorSegmentedControl = @"selectorSegmentedControl";NSString *const XLFormRowDescriptorTypeDateInline = @"dateInline";NSString *const XLFormRowDescriptorTypeDateTimeInline = @"datetimeInline";NSString *const XLFormRowDescriptorTypeTimeInline = @"timeInline";NSString *const XLFormRowDescriptorTypeCountDownTimerInline = @"countDownTimerInline";NSString *const XLFormRowDescriptorTypeDate = @"date";NSString *const XLFormRowDescriptorTypeDateTime = @"datetime";NSString *const XLFormRowDescriptorTypeTime = @"time";NSString *const XLFormRowDescriptorTypeCountDownTimer = @"countDownTimer";NSString *const XLFormRowDescriptorTypeDatePicker = @"datePicker";NSString *const XLFormRowDescriptorTypePicker = @"picker";NSString *const XLFormRowDescriptorTypeSlider = @"slider";NSString *const XLFormRowDescriptorTypeBooleanCheck = @"booleanCheck";NSString *const XLFormRowDescriptorTypeBooleanSwitch = @"booleanSwitch";NSString *const XLFormRowDescriptorTypeButton = @"button";NSString *const XLFormRowDescriptorTypeInfo = @"info";NSString *const XLFormRowDescriptorTypeStepCounter = @"stepCounter"; 位于框架内 XLForm.h 头文件中,请自行参看 自定义 cell当框架自带的 XLFormRowDescriptorType 无法满足实际需求的时候,我们需要自定义. 如何自定义一个 XLFormRowDescriptorType我们必须重写如下三个方法:1.load 注册自定义的 cell. 2.configure 初始化一些 cell 配置信息. 3.update 更新 XLFromRowDescriptor 对象的 value 属性值. 如何自定义 cell下面演示如何自定义一个上边 UILabel 下边 UITextField 的自定义 cell, 用到了 Masonry 老司机自行导入. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#import "SampleCustomCell.h"#import &lt;XLForm/XLForm.h&gt;#import &lt;Masonry.h&gt;NSString *const SampleCustomCellType = @"SampleCustomCellType";@interface SampleCustomCell()&lt;UITextFieldDelegate&gt;/** Label for display tip */@property (nonatomic, strong) UILabel *tipLabel;/** textField for Receive input text */@property (nonatomic, strong) UITextField *inputTextField;@end@implementation SampleCustomCell+ (void)load &#123; [XLFormViewController.cellClassesForRowDescriptorTypes setObject:[self class] forKey:SampleCustomCellType];&#125;- (void)configure &#123; [super configure]; [self setupUI]; [self makeConstraint];&#125;- (void)update &#123; [super update]; self.textLabel.text = self.rowDescriptor.title;&#125;#pragma mark - =========================================== layout ===================================- (void)setupUI &#123; [self.contentView addSubview:self.tipLabel]; [self.contentView addSubview:self.inputTextField];&#125;- (void)makeConstraint &#123; [self.textLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.contentView).offset(10); make.left.equalTo(self.contentView).offset(20); &#125;]; [self.inputTextField mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.textLabel); make.top.equalTo(self.textLabel.mas_bottom).offset(10); make.right.equalTo(self.contentView).offset(-20); make.height.mas_equalTo(44); make.bottom.equalTo(self.contentView).offset(-10); &#125;];&#125;#pragma mark - =========================================== lazy load ===================================- (UILabel *)tipLabel &#123; if(_tipLabel) return _tipLabel; _tipLabel = [UILabel new]; _tipLabel.textColor = HEXCOLOR(0xFF8A00); return _tipLabel;&#125;- (UITextField *)inputTextField &#123; if(_inputTextField) return _inputTextField; _inputTextField = [UITextField new]; _inputTextField.delegate = self; _inputTextField.layer.borderColor = HEXCOLOR(0xFF8A00).CGColor; _inputTextField.layer.borderWidth = 1; return _inputTextField;&#125;- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated];&#125;@end 但是键盘有问题,选中的背景色有问题,需要改造一下.1234567891011121314151617- (void)configure &#123; [super configure]; [self setupUI]; [self makeConstraint]; [self setSelectionStyle:UITableViewCellSelectionStyleNone];&#125;.......- (BOOL)formDescriptorCellCanBecomeFirstResponder &#123; return (!self.rowDescriptor.isDisabled);&#125;- (BOOL)formDescriptorCellBecomeFirstResponder &#123; return [self.inputTextField becomeFirstResponder];&#125; 好了,简单的自定义完成了. 表单数据的获取在 viewController 中1[self.form formValues]; 获取表单的值,其返回值是字典类型1234formValues = &#123; PhoneRow = 5158; SampleRow = "&lt;null&gt;";&#125; 你没有看错,刚才我们自定义的 cell 的表单值是 &quot;&lt;null&gt;&quot; ,不是因为没有输入值,而是没有给 rowDescriptor.value 赋值,继续改造一下. 1234567// 添加事件[_inputTextField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged];// 赋值- (void)textFieldDidChange:(UITextField *)textField &#123; self.rowDescriptor.value = textField.text;&#125; 1234formValues = &#123; PhoneRow = "5158"; SampleRow = Ooops;&#125; 数据合法性校验器 XLFormValidator上面的例子,再给加点料.粗糙一点的数据合法性验证1234567891011121314#pragma mark - Helper- (void)textFieldDidChange:(UITextField *)textField &#123; UITextRange *rang = textField.markedTextRange; if (rang == nil) &#123; if(textField.text.length &gt; 8 )&#123; NSRange range = NSMakeRange(0, 8); textField.text = [textField.text substringWithRange:range]; self.rowDescriptor.value = textField.text; NSLog(@"最多输入8个字符"); &#125;else&#123; self.rowDescriptor.value = textField.text; &#125; &#125;&#125; 这么做其实也是可以的,但是框架提供了 XLFormValidator 数据校验类. 我们来看看如何使用 XLFormValidator 的创建创建一个继承自 XLFormValidator 的 SampleValidator 类文件,使用正则表达式的方式验证数据合法性..h1234567#import "XLFormValidator.h"@interface SampleValidator : XLFormValidator+ (XLFormValidator *)sampleValidator;@end .m1234567891011121314#import "SampleValidator.h"#import "XLFormRegexValidator.h"@implementation SampleValidator- (XLFormValidationStatus *)isValid:(XLFormRowDescriptor *)row &#123; return [XLFormValidationStatus formValidationStatusWithMsg:nil status:YES rowDescriptor:row];&#125;+ (XLFormValidator *)sampleValidator &#123; return [XLFormRegexValidator formRegexValidatorWithMsg:NSLocalizedString(@"最多输入8个字符", nil) regex:@"^.&#123;0,8&#125;$"];&#125;@end XLFormValidator 的使用在 viewController 中 为先前创建的自定义 cell 添加刚创建的 数据合法性 校验器,且设为 必填项 .1234#import "SampleValidator.h"......[sampleRow addValidator:[SampleValidator sampleValidator]];sampleRow.required = YES; 继续改造一下代码. 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)values:(UIButton *)sender &#123; if(![self validatorAction]) &#123; return; &#125; NSDictionary *values = [self.form formValues]; NSLog(@"formValues = %@",values); // 接口调用...balabalabala&#125;#pragma mark - =========================================== 数据合法性校验 ===================================- (BOOL)validatorAction &#123; NSArray * array = [self.form localValidationErrors:self]; BOOL isValidator; if(array.count &gt; 0) &#123; [array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; XLFormValidationStatus * validationStatus = [[obj userInfo] objectForKey:XLValidationStatusErrorKey]; if ([validationStatus.rowDescriptor.tag isEqualToString:sampleRowTag] &amp;&amp; !validationStatus.isValid) &#123; *stop = YES; NSLog(@"请修正数据"); &#125; UITableViewCell * cell = [self.tableView cellForRowAtIndexPath:[self.form indexPathOfFormRow:validationStatus.rowDescriptor]]; [self animateCell:cell]; &#125;]; isValidator = NO; &#125; else &#123; isValidator = YES; &#125; return isValidator;&#125;// 验证数据错误的cell动画- (void)animateCell:(UITableViewCell *)cell &#123; CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @"position.x"; animation.values = @[ @0, @20, @-20, @10, @0]; animation.keyTimes = @[@0, @(1 / 6.0), @(3 / 6.0), @(5 / 6.0), @1]; animation.duration = 0.3; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]; animation.additive = YES; [cell.layer addAnimation:animation forKey:@"shake"];&#125; 只是一个自定义 cell 控制器的代码已经有点多了.下面我们抽离一下 1. 抽离 cell tag 的常量定义到 CustomConst 文件中 ..h1234#import &lt;Foundation/Foundation.h&gt;extern NSString *const phoneRowTag;extern NSString *const sampleRowTag; .m1234#import "CustomConst.h"NSString *const phoneRowTag = @"phoneRowTag";NSString *const sampleRowTag = @"sampleRowTag"; 2. 抽离 initForm 表单创建方法到 CustomFactory 文件.h1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import &lt;XLFormViewController.h&gt;@interface CustomFactory : NSObject/** delegate */@property (nonatomic, weak) XLFormViewController *delegate;/** xlForm */@property (nonatomic, weak) XLFormDescriptor *form;/** 初始化表单方法 */- (void)initForm;@end .m123456789101112131415161718192021222324252627282930313233343536373839404142434445#import "CustomFactory.h"#import "CustomConst.h"#import "SampleValidator.h"#import "SampleCustomCell.h"#import &lt;XLForm.h&gt;@implementation CustomFactory- (void)initForm &#123; XLFormSectionDescriptor * sampleSection = [XLFormSectionDescriptor formSectionWithTitle:@"First Section"]; [sampleSection addFormRow:[self rowFactoryWithWithTitle:@"" tag:phoneRowTag required:YES rowType:XLFormRowDescriptorTypePhone placeholder:@""]]; [sampleSection addFormRow:[self rowFactoryWithWithTitle:@"自定义的tip" tag:sampleRowTag required:YES rowType:SampleCustomCellType placeholder:@"最长八位字符"]]; [self.form addFormSection:sampleSection];&#125;- (XLFormRowDescriptor *)rowFactoryWithWithTitle:(NSString *)headerTitle tag:(NSString *)tag required:(BOOL)required rowType:(NSString *)rowType placeholder:(NSString *)placeholder &#123; XLFormRowDescriptor *row; row = [XLFormRowDescriptor formRowDescriptorWithTag:tag rowType:rowType]; if(tag == sampleRowTag) &#123; [row addValidator:[SampleValidator sampleValidator]]; [row.cellConfigAtConfigure setObject:placeholder forKey:@"inputTextField.placeholder"]; &#125; if(required) &#123; row.requireMsg = @"带*为必填!"; &#125; row.required = required; row.title = headerTitle; row.height = UITableViewAutomaticDimension; return row;&#125;@end 3. 抽离 validatorAction 数据合法校验方法 到 CustomValidator 文件中 .h12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;XLForm.h&gt;@interface CustomValidator : NSObject/** 验证表格 */@property (nonatomic, weak) UITableView *tableView;/** xlForm */@property (nonatomic, weak) XLFormDescriptor *form;/** delegate */@property (nonatomic, weak) XLFormViewController *delegate;/** 所有数据是否校验完毕 */@property (nonatomic,assign) BOOL isValidate;/** 验证表单数据的方法 */- (void)validatorAction;@end .m123456789101112131415161718192021222324252627282930313233343536373839#import "CustomValidator.h"#import "CustomConst.h"@implementation CustomValidator#pragma mark - cell数据合法化验证方法- (NSArray *)formValidationErrors &#123; return [self.form localValidationErrors:self.delegate];&#125;#pragma mark - 数据校验器- (void)validatorAction &#123; NSArray * array = [self formValidationErrors]; self.isValidate = !(array.count &gt; 0); [array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; XLFormValidationStatus * validationStatus = [[obj userInfo] objectForKey:XLValidationStatusErrorKey]; if ([validationStatus.rowDescriptor.tag isEqualToString:sampleRowTag] &amp;&amp; !validationStatus.isValid) &#123; *stop = YES; NSLog(@"请修正数据"); &#125; UITableViewCell * cell = [self.tableView cellForRowAtIndexPath:[self.form indexPathOfFormRow:validationStatus.rowDescriptor]]; [self animateCell:cell]; &#125;];&#125;// 验证数据错误的cell动画- (void)animateCell:(UITableViewCell *)cell &#123; CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @"position.x"; animation.values = @[ @0, @20, @-20, @10, @0]; animation.keyTimes = @[@0, @(1 / 6.0), @(3 / 6.0), @(5 / 6.0), @1]; animation.duration = 0.3; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]; animation.additive = YES; [cell.layer addAnimation:animation forKey:@"shake"];&#125;@end viewController 中的代码变成了这样12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#import "ViewController.h"#import &lt;XLForm/XLFormViewController.h&gt;#import &lt;XLForm.h&gt;#import &lt;Masonry.h&gt;#import "CustomFactory.h"#import "CustomValidator.h"@interface ViewController ()/** button for get form values */@property (nonatomic, strong) UIButton *valuesButton;/** custom factory */@property (nonatomic, strong) CustomFactory *customFactory;/** Custom Validator */@property (nonatomic, strong) CustomValidator *customValidator;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self initForm]; [self setupUI]; [self makeConstraint]; &#125;- (void)setupUI &#123; [self.view addSubview:self.valuesButton];&#125;- (void)makeConstraint &#123; [self.tableView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.top.right.equalTo(self.view); make.bottom.mas_equalTo(-100); &#125;]; [self.valuesButton mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.right.bottom.equalTo(self.view); make.height.mas_equalTo(50); &#125;];&#125;- (void)initForm &#123; self.form = [XLFormDescriptor formDescriptorWithTitle:@"First Form"]; self.customFactory.form = self.form; self.customFactory.delegate = self; self.customValidator.form = self.form; self.customValidator.delegate = self; self.customValidator.tableView = self.tableView; [self.customFactory initForm];&#125;#pragma mark - =========================================== lazy load ===================================- (UIButton *)valuesButton &#123; if(_valuesButton) return _valuesButton; _valuesButton = [UIButton buttonWithType:0]; [_valuesButton setTitle:@"Values" forState:UIControlStateNormal]; [_valuesButton setBackgroundColor:HEXCOLOR(0xFF8A00)]; [_valuesButton setTitleColor:HEXCOLOR(0xFFFFFF) forState:UIControlStateNormal]; [_valuesButton addTarget:self action:@selector(values:) forControlEvents:UIControlEventTouchUpInside]; return _valuesButton;&#125;- (CustomFactory *)customFactory &#123; if(_customFactory) return _customFactory; _customFactory = [CustomFactory new]; return _customFactory;&#125;- (CustomValidator *)customValidator &#123; if(_customValidator) return _customValidator; _customValidator = [CustomValidator new]; return _customValidator;&#125;- (void)values:(UIButton *)sender &#123; [self.customValidator validatorAction]; if(!self.customValidator.isValidate) return; NSDictionary *values = [self.form formValues]; NSLog(@"formValues = %@",values);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 所有跟表单有关的东西都抽离出去. 有种 万花丛中过,便宜不沾身 的感觉,有没有. 结语后面有机会介绍更加复杂的自定义 cell… 补上长久以来缺失的 Demo]]></content>
      <categories>
        <category>XLForm</category>
      </categories>
      <tags>
        <tag>XLForm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins一键发布 ipa 到蒲公英]]></title>
    <url>%2F2017%2F03%2F12%2FJenkins%2F</url>
    <content type="text"><![CDATA[图已补 😓2017.05.20 由于不小心删除了配图仓库,图片都看不见了,有时间再给补上, 各位观众老爷,轻喷什么是 JenkinsJenkins是一个持续集成工具，它可以在设定的某个时间点（或者代码有更新等情况）自动去构建安装包，同时可以将安装包上传到第三方平台，比如：Bugly、蒲公英，这样测试人员可以通过微信、QQ扫一扫直接安装 附上下载地址 :Jenkins 建议下载 .war文件 配合Tomcat环境使用. 直接下载了.war文件，这个文件是直接放在Tomcat下webapps目录下. 优点:它的权限就是当前用户. 开始安装Tomcat 附上下载地址 :Tomcat 把下载好的 Tomcat 文件夹 放到你想放的目录 然后把 .war 文件放入 Tomcat文件夹下的 webapps 目录下 运行Jenkins命令行进入Tomcat安装目录. cd /Users/ooops/apache-tomcat-7.0.75/bin 可能会报 -bash: /Users/ooops/apache-tomcat-7.0.75/bin/startup.sh: Permission denied错误,这是因为对该文件没有执行权限造成的. 执行如下命令: chmod +x *.sh 然后执行 sh startup.sh 打开浏览器输入 localhost:8080 看到 Tomcat启动页面,表示Tomcat安装成功 进入Tomcat目录下 conf打开 tomcat-users.xml文件,在文件根节点结束之前添加如下配置 12&lt;role rolename="manager-gui"/&gt;&lt;user username="admin" password="admin" roles="manager-gui"/&gt; 设置Tomcat的登录信息 使用如下命令重启Tomcat cd /Users/ooops/apache-tomcat-7.0.75/bin sh shutdown.sh sh startup.sh 再次访问 localhost:8080 选择 Manager Apps 登录Tomcat,选择列表中Jenkins 输入如下命令查看Jenkins初始密码 open /Users/ooops/.jenkins/secrets/initialAdminPassword 粘贴初始密码,点击继续,等待片刻 选择Install suggested plugins 安装推荐的 Jenkins 插件 推荐的插件安装完毕,还有我们自己需要的插件安装 首先进入插件管理器界面,进入方式: 系统管理-&gt;管理插件 在可选插件中搜索我们需要的插件,进行安装 GIT 环境下我们需要安装的插件有 三 个 Gitlab Hook Plugin 因为我们用的是GitLab来管理源代码，Jenkins本身并没有自带GitLab插件 Xcode Xcode环境插件. Keychains and Provisioning Profiles Management 钥匙串和证书配置 配置GIT私钥文件位置 家目录下的 .ssh 文件夹下 配置GIT 私钥 钥匙串和证书配置进入方式: 系统管理-&gt;Keychains and Provisioning Profiles Management 钥匙串文件路径 : /Users/用户名(your user name)/Library/Keychains/login.keychain 上传钥匙串 keychain 和 证书描述文件 Provisioning Profile 上传之后的要是串和证书描述文件会被Jenkins 保存在/Users/改成你的(your user name)/.jenkins/kpp_upload目录下 配置对应的钥匙串中的开发(调试) 生产(发布) 证书 首先打开钥匙串,获取证书的常用名称 我们将证书的常用名称点入 钥匙串的配置中,具体配置参考下图 上图目录配置,改为/Users/改成你的(your user name)/.jenkins/kpp_upload.偷个懒 不补图了. 点击确定完成配置. 系统全局配置Jenkins 主页 -&gt; 系统管理 -&gt; 系统设置 -&gt; 全局属性 -&gt; 勾选Keychains and Provisioning Profiles Management 填入上传到 Jenkins 的证书和描述文件目录 /Users/ooops(你的用户名)/.jenkins/kpp_upload 下面开始构建项目配置.创建一个多配置的项目 General 参数 源码管理 参数 构建触发器设置这里是设置自动化测试的地方。涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以 研究研究这里的设置。 不过这里两个配置还是需要是设置的 Poll SCM (poll source code management) 轮询源码管理 需要设置源码的路径才能起到轮询的效果。 一般设置为类似结果： 0/5 每5分钟轮询一次 Build periodically (定时构建) 一般设置为类似： 00 20 * 每天 20点执行定时构建 格式如下 (具体可以参考后面的小问号??) 嘿嘿 分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日) 设置之后文本输入域下面会有你填写格式的翻译. 参数配置参考： https://blog.csdn.net/xueyingqi/article/details/53216506 https://blog.csdn.net/yezicjj/article/details/52763700 构建环境 参数参考下图设置 请参考 钥匙串和证书配置 中关于钥匙串的配置. 构建 设置 # 工程名 APP_NAME="你的项目名称" # 证书 CODE_SIGN_DISTRIBUTION="iPhone Developer: XXXXXXX" #CODE_SIGN_DISTRIBUTION="iPhone Distribution: XXXXXXXXXX" # info.plist路径 project_infoplist_path="./${APP_NAME}/Info.plist" #取版本号 bundleShortVersion=$(/usr/libexec/PlistBuddy -c "print CFBundleShortVersionString" "${project_infoplist_path}") #取build值 bundleVersion=$(/usr/libexec/PlistBuddy -c "print CFBundleVersion" "${project_infoplist_path}") DATE="$(date +%Y%m%d)" IPANAME="${APP_NAME}_V${bundleShortVersion}_${DATE}.ipa" #IPANAME="${APP_NAME}.ipa" #要上传的ipa文件路径 IPA_PATH="$HOME/${IPANAME}" echo ${IPA_PATH} echo "${IPA_PATH}">> text.txt #下面2行是没有Cocopods的用法 echo "=================clean=================" xcodebuild -target "${APP_NAME}" -configuration 'Release' clean echo "+++++++++++++++++build+++++++++++++++++" xcodebuild -target "${APP_NAME}" -sdk iphoneos -configuration 'Release' CODE_SIGN_IDENTITY="${CODE_SIGN_DISTRIBUTION}" SYMROOT='$(PWD)' #//下面2行是集成有Cocopods的用法 #echo "=================clean=================" #xcodebuild -workspace "${APP_NAME}.xcworkspace" -scheme "${APP_NAME}" -configuration 'Release' clean #echo "+++++++++++++++++build+++++++++++++++++" #xcodebuild -workspace "${APP_NAME}.xcworkspace" -scheme "${APP_NAME}" -sdk iphoneos -configuration 'Release' CODE_SIGN_IDENTITY="${CODE_SIGN_DISTRIBUTION}" SYMROOT='$(PWD)' xcrun -sdk iphoneos PackageApplication "./Release-iphoneos/${APP_NAME}.app" -o ~/"${IPANAME}" #蒲公英上的User Key uKey="9b0aa78a32a......4e1ca68bdbf" #蒲公英上的API Key apiKey="ac75fcf38.....7b9f19f2e4b23" #要上传的ipa文件路径 IPA_PATH=$(cat text.txt) rm -rf text.txt #执行上传至蒲公英的命令 echo "++++++++++++++upload+++++++++++++" curl -F "file=@${IPA_PATH}" -F "uKey=${uKey}" -F "_api_key=${apiKey}" https://www.pgyer.com/apiv1/app/upload 构建项目以下是一次成功构建的输出信息 Started by user ooops Building in workspace /Users/ooops/.jenkins/workspace/test > git rev-parse --is-inside-work-tree # timeout=10 Fetching changes from the remote Git repository //拉取GIT仓库 > git config remote.origin.url git@github.com:xxxxx/jenkinsTest.git # timeout=10 Fetching upstream changes from git@github.com:xxxxx/jenkinsTest.git > git --version # timeout=10 > git fetch --tags --progress git@github.com:xxxxx/jenkinsTest.git +refs/heads/*:refs/remotes/origin/* > git rev-parse refs/remotes/origin/master^{commit} # timeout=10 > git rev-parse refs/remotes/origin/origin/master^{commit} # timeout=10 Checking out Revision 1f023f0132273ddc4d3d98a8283e3a15bbe254aa (refs/remotes/origin/master) > git config core.sparsecheckout # timeout=10 > git checkout -f 1f023f0132273ddc4d3d98a8283e3a15bbe254aa > git rev-list 1f023f0132273ddc4d3d98a8283e3a15bbe254aa # timeout=10 [test] $ /bin/sh -xe /Users/ooops/apache-tomcat-7.0.75/temp/hudson6997647762219224773.sh + APP_NAME=jenkinsTest + CODE_SIGN_DISTRIBUTION='iPhone Developer: xxxxx' + project_infoplist_path=./jenkinsTest/Info.plist ++ /usr/libexec/PlistBuddy -c 'print CFBundleShortVersionString' ./jenkinsTest/Info.plist + bundleShortVersion=1.0 ++ /usr/libexec/PlistBuddy -c 'print CFBundleVersion' ./jenkinsTest/Info.plist + bundleVersion=1 ++ date +%Y%m%d + DATE=20170312 + IPANAME=jenkinsTest_V1.0_20170312.ipa + IPA_PATH=/Users/ooops/jenkinsTest_V1.0_20170312.ipa + echo /Users/ooops/jenkinsTest_V1.0_20170312.ipa /Users/ooops/jenkinsTest_V1.0_20170312.ipa + echo /Users/ooops/jenkinsTest_V1.0_20170312.ipa + echo =================clean================= =================clean================= + xcodebuild -target jenkinsTest -configuration Release clean 2017-03-12 12:56:15.278 xcodebuild[12363:1935879] [MT] PluginLoading: Required plug-in compatibility UUID DAxxxD8-C509-4xB-8xx5-84xxxxxxx701 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/VVDocumenter-Xcode.xcplugin' not present in DVTPlugInCompatibilityUUIDs 2017-03-12 12:56:15.279 xcodebuild[12363:1935879] [MT] PluginLoading: Required plug-in compatibility UUID DAxxxD8-C509-4xB-8xx5-84xxxxxxx701 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/HOStringSense.xcplugin' not present in DVTPlugInCompatibilityUUIDs 2017-03-12 12:56:15.280 xcodebuild[12363:1935879] [MT] PluginLoading: Required plug-in compatibility UUID DAxxxD8-C509-4xB-8xx5-84xxxxxxx701 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/ESJsonFormat.xcplugin' not present in DVTPlugInCompatibilityUUIDs 2017-03-12 12:56:15.280 xcodebuild[12363:1935879] [MT] PluginLoading: Required plug-in compatibility UUID DAxxxD8-C509-4xB-8xx5-84xxxxxxx701 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Auto-Importer.xcplugin' not present in DVTPlugInCompatibilityUUIDs === CLEAN TARGET jenkinsTest OF PROJECT jenkinsTest WITH CONFIGURATION Release === Check dependencies Create product structure /bin/mkdir -p /Users/ooops/.jenkins/workspace/test/build/Release-iphoneos/jenkinsTest.app Clean.Remove clean build/jenkinsTest.build/Release-iphoneos/jenkinsTest.build builtin-rm -rf /Users/ooops/.jenkins/workspace/test/build/jenkinsTest.build/Release-iphoneos/jenkinsTest.build Clean.Remove clean build/Release-iphoneos/jenkinsTest.app builtin-rm -rf /Users/ooops/.jenkins/workspace/test/build/Release-iphoneos/jenkinsTest.app Clean.Remove clean build/Release-iphoneos/jenkinsTest.app.dSYM builtin-rm -rf /Users/ooops/.jenkins/workspace/test/build/Release-iphoneos/jenkinsTest.app.dSYM ** CLEAN SUCCEEDED ** + echo +++++++++++++++++build+++++++++++++++++ +++++++++++++++++build+++++++++++++++++ + xcodebuild -target jenkinsTest -sdk iphoneos -configuration Release 'CODE_SIGN_IDENTITY=iPhone Developer: xxxxxxxxxxxxxxxx' 'SYMROOT=$(PWD)' 2017-03-12 12:56:16.118 xcodebuild[12376:1936105] [MT] PluginLoading: Required plug-in compatibility UUID DAxxxx8-C509-4xxB-8B55-84AxxxxxE701 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/VVDocumenter-Xcode.xcplugin' not present in DVTPlugInCompatibilityUUIDs 2017-03-12 12:56:16.119 xcodebuild[12376:1936105] [MT] PluginLoading: Required plug-in compatibility UUID DAxxxxD8-C509-4D8B-8xxxx-84Axxxx01 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/HOStringSense.xcplugin' not present in DVTPlugInCompatibilityUUIDs 2017-03-12 12:56:16.119 xcodebuild[12376:1936105] [MT] PluginLoading: Required plug-in compatibility UUID DA4xxx8-C509-4Dxx-8xx5-84AxxxE701 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/ESJsonFormat.xcplugin' not present in DVTPlugInCompatibilityUUIDs 2017-03-12 12:56:16.120 xcodebuild[12376:1936105] [MT] PluginLoading: Required plug-in compatibility UUID Dxxxx8-C509-xx-8B55-84xxxxxAE701 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Auto-Importer.xcplugin' not present in DVTPlugInCompatibilityUUIDs Build settings from command line: CODE_SIGN_IDENTITY = iPhone Developer: qiang zhang (36XGYU49EQ) SDKROOT = iphoneos10.1 SYMROOT = $(PWD) === BUILD TARGET jenkinsTest OF PROJECT jenkinsTest WITH CONFIGURATION Release === Check dependencies Validate Release-iphoneos/jenkinsTest.app cd /Users/ooops/.jenkins/workspace/test export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/ooops/.rvm/gems/ruby-2.2.2/bin:/Users/ooops/.rvm/gems/ruby-2.2.2@global/bin:/Users/ooops/.rvm/rubies/ruby-2.2.2/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/ooops/.rvm/bin:/Users/ooops/.rvm/bin" export PRODUCT_TYPE=com.apple.product-type.application builtin-validationUtility /Users/ooops/.jenkins/workspace/test/Release-iphoneos/jenkinsTest.app -validate-for-store ** BUILD SUCCEEDED ** + xcrun -sdk iphoneos PackageApplication ./Release-iphoneos/jenkinsTest.app -o /Users/ooops/jenkinsTest_V1.0_20170312.ipa warning: PackageApplication is deprecated, use `xcodebuild -exportArchive` instead. //这里是上传蒲公英的配置. + uKey=9b0aa78a32........64e1ca68bdbf + apiKey=ac75fcf3..........a47b9f19f2e4b23 ++ cat text.txt + IPA_PATH=/Users/ooops/jenkinsTest_V1.0_20170312.ipa + rm -rf text.txt + echo ++++++++++++++upload+++++++++++++ ++++++++++++++upload+++++++++++++ + curl -F file=@/Users/ooops/jenkinsTest_V1.0_20170312.ipa -F uKey=9b0aa78a32...af26..4e1ca68bdbf -F _api_key=ac75fcf38f2.........19f2e4b23 http://www.pgyer.com/apiv1/app/upload % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0 100 32843 0 0 100 32843 0 21213 0:00:01 0:00:01 --:--:-- 21202 100 32843 0 0 100 32843 0 12862 0:00:02 0:00:02 --:--:-- 12859 100 33438 100 595 100 32843 220 12149 0:00:02 0:00:02 --:--:-- 12146 {"code":0,"message":"","data":{"appKey":"dd580f5...........0305ac671","userKey":"9b0aa78a.........e1ca68bdbf","appType":"1","appIsLastest":"1","appFileSize":"32368","appName":"jenkinsTest","appVersion":"1.0","appVersionNo":"1","appBuildVersion":"2","appIdentifier":"com.ooops.pull","appIcon":"","appDescription":"","appUpdateDescription":"","appScreenshots":"","appShortcutUrl":"nZwg","appCreated":"2017-03-12 12:56:18","appUpdated":"2017-03-12 12:56:18","appQRCodeURL":"http:\/\/static.pgyer.com\/app\/qrcodeHistory\/ea895709d0e57a4a8e4c8f57811838b2ce985322a94f9443e64a0937c6d29e30"}}Finished: SUCCESS 上传到蒲公英 END]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode8控制台乱码问题]]></title>
    <url>%2F2016%2F10%2F20%2Fxcode%2F</url>
    <content type="text"><![CDATA[之前解决控制台log输出的方式Xcode8里边 Edit Scheme-&gt; Run -&gt; Arguments, 在Environment Variables里边添加 OS_ACTIVITY_MODE ＝ Disable 环境变量 ,这个相信大家都会. 使用改变Xcode系统模板的方式先介绍几个c函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** *getenv（取得环境变量内容） *定义函数 char * getenv(const char *name); *函数说明 getenv()用来取得参数name环境变量的内容。 *参数说明 *name为环境变量的名称，如果该变量存在则会返回指向该内容的指针。 *环境变量的格式为name＝value。 *返回值：执行成功则返回指向该内容的指针，找不到符合的环境变量名称则返回NULL。 */- (void)getenv_test:(char *)env_name&#123; if(getenv(env_name)) &#123; printf("%s's value = %s",env_name,getenv(env_name)); &#125;&#125;/** *putenv（改变或增加环境变量） *定义函数 int putenv(const char * string); *函数说明：putenv()用来改变或增加环境变量的内容。 *参数 *string的格式为name ＝ value， *如果该环境变量原先存在，则变量内 容会依参数string改变，否则此参数内容会成为新的环境变量。 *返回值：执行成功则返回0，有错误发生则返回-1。 */- (void)putenv_test&#123; char *env_name = "test_two"; if(putenv(env_name) == 0) &#123; printf("%s = %d",env_name,putenv("test_two = two")); &#125; &#125;/** *unsetenv（移除环境变量） *定义函数 unsetenv(const char *string); *函数说明：unsetenv()用来改变或增加环境变量的内容。 *参数 *string为环境变量的名称， *如果该环境变量原先存在,则移除该环境变量。 *返回值：执行成功则返回0，有错误发生则返回-1。 */- (void)unsetenv_test&#123; char *env_name = "test_one"; if(unsetenv(env_name) == 0) &#123; printf("%s is unseted = %s",env_name,unsetenv(env_name) == 0 ? "yes" : "no"); &#125;&#125;/**setenv（改变或增加环境变量） *定义函数 int setenv(const char *name,const char * value,int overwrite); *函数说明 setenv()用来改变或增加环境变量的内容。 *参数 name为环境变量名称字符串。 *参数 value则为变量内容。 *参数 overwrite用来决定是否要改变已存在的环境变量。 如果overwrite不为0，则改变环境变量原有内容，原有内容会被改为参数value所指的变量内容。 如果overwrite为0，且该环境变量已有内容，则参数value会被忽略。 *返回值 执行成功则返回0，有错误发生时返回-1*/- (void)setenv_test&#123; char *env_name = "test_one"; char *env_value = "ooops"; if(setenv(env_name,env_value,1) == 0) &#123; printf("%s is seted = %s",env_name,setenv(env_name,env_value,1) == 0 ? "success" : "failed"); &#125;&#125; 我们要修改的模板如下的路径中12/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project\ Templates/iOS/Application/Cocoa\ Touch\ Application\ Base.xctemplate 打开文件,在文件中搜索如下代码12345&lt;key&gt;main.m:main:UIApplicationMain&lt;/key&gt;&lt;string&gt;@autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#125;&lt;/string&gt; 将其改为12345678&lt;key&gt;main.m:main:UIApplicationMain&lt;/key&gt; &lt;string&gt;@autoreleasepool &#123; /* * 此行代码是增加的代码 */ setenv("OS_ACTIVITY_MODE", "DISABLE", 1); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#125; 其目的是为了,在创建的Xcode项目的入口文件中增加添加环境变量的操作 效果如下12345678910111213141516171819//// main.m// environment_variable//// Created by 张强 on 16/10/20.// Copyright © 2016年 张强. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;#import "AppDelegate.h"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; setenv("OS_ACTIVITY_MODE", "disable", 1); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 至此解决Xcode8创建新项目,控制台会出现奇葩log的小缺陷!]]></content>
      <categories>
        <category>Xcode 8</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog 伊始]]></title>
    <url>%2F2015%2F06%2F11%2Fblog-initial-construction%2F</url>
    <content type="text"><![CDATA[来来来, 写一篇每个程序员都会写的 Hello World, 记录一下 blog 的开通. 作为一个程序员, 是应该倒腾倒腾自己的Blog, 于是乎就开始了撸起袖子干了.]]></content>
      <categories>
        <category>伊始</category>
      </categories>
      <tags>
        <tag>味</tag>
      </tags>
  </entry>
</search>
